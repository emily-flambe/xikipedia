<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Xikipedia</title>
    <meta property="og:url" content="https://xikipedia.emilycogsdill.com/">
    <meta property="og:title" content="Xikipedia">
    <meta name="description" content="Wikipedia you can doomscroll">
    <meta property="og:description" content="Wikipedia you can doomscroll">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta content="#38444D" name="theme-color">
    <link rel="icon" href="/favicon.ico">
    <style>
        html, body {
            background: #15202B;
            color: #FFF;
            font-family: system-ui, sans-serif;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            justify-content: center;
        }
        .posts {
            max-width: 600px;
            width: 100vw;
            border: 1px solid #38444D;
            border-top: none;
            height: fit-content;
        }
        .posts:has(.post) {
            margin-bottom: 1000px;
        }
        .stats {
            max-width: 300px;
            border: 1px solid #38444D;
            border-radius: 8px;
            position: fixed;
            left: calc(50% + 330px);
            top: 20px;
            padding: 8px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
        }
        @media (max-width: 1000px) {
            .stats {
                display: none;
            }
        }
        .post {
            padding: 12px 24px;
            border-top: 1px solid #38444D;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: pointer;
        }
        .post:hover,
        .post:focus {
            background: #1C2732;
        }
        .post:focus {
            outline: 2px solid #2cafff;
            outline-offset: -2px;
        }
        .post h1 {
            font-size: 100%;
            margin: 0;
        }
        .post p {
            margin: 0;
            word-break: break-word;
        }
        .post button {
            align-self: end;
            margin: -4px;
            margin-top: 4px;
            padding: 4px;
            background: transparent;
            transition: background 0.2s, transform 0.2s cubic-bezier(.15,.67,0,1);
            border-radius: 64px;
            font-size: 0;
            border: 0;
            cursor: pointer;
        }
        .post button:hover:not([data-liked]) {
            background: rgba(255,255,255,0.13);
            transform: scale(1.1);
        }
        .post button:active:not([data-liked]),
        .post button:active {
            transform: scale(0.9);
        }
        .post button::after {
            font-size: 16px;
            display: block;
            width: 24px;
            height: 24px;
            margin-top: 1px;
            margin-bottom: -1px;
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="none" stroke="%2389A" stroke-linejoin="round"/></svg>');
        }
        .post button[data-liked]::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="red" stroke="red"/></svg>');
        }
        .post img.media {
            border-radius: 16px;
            border: 1px solid #38444D;
            display: block;
            margin: 8px 0;
            max-width: min(512px, 100%);
            max-height: 330px;
            background: #FFF;
        }
        .fullImg {
            max-height: 95%;
            max-width: 95%;
            min-width: 25%;
            min-height: 25%;
        }
        body ::backdrop {
            background: rgba(0,0,0,0.6);
        }
        #startScreen {
            display: flex;
            flex-direction: column;
            background: #15202B;
            border: none;
            width: 90%;
            height: 90%;
            max-width: 600px;
            color: #fff;
            border-radius: 8px;
            padding: 32px;
            box-sizing: border-box;
        }
        #startScreen h1,
        #startScreen h2 {
            margin: 0;
        }
        #categoryPickList {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }
        .categoryPicker {
            border-radius: 100px;
            cursor: pointer;
            padding: 10px;
            display: inline-flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: inset 0px 0px 1.2px 0px #000;
            background: #1C2732;
            color: #E8E8E8;
        }
        .categoryPicker::after {
            content: "+";
            color: #2cafff;
            font-size: 150%;
            line-height: 0;
            margin-left: 8px;
        }
        .categoryPicker:hover,
        .categoryPicker:active {
            background: #38444D;
        }
        .categoryPicker:has(input:checked) {
            background: #FFF;
            color: #000;
        }
        .categoryPicker:has(input:checked)::after {
            content: "−";
            color: #000;
        }
        .categoryPicker:has(input:focus-visible) {
            outline: 2px solid #2cafff;
        }
        .categoryPicker input {
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }
        #startBtn {
            border-radius: 32px;
            padding: 12px;
            background: #2cafff;
            color: #FFF;
            border: 1px solid #000;
            font: inherit;
            cursor: pointer;
        }
        #startBtn[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch {
            margin: 8px 0;
            gap: 8px;
        }
        #categorySearch input {
            border-radius: 32px;
            padding: 12px;
            background: #000;
            color: #FFF;
            border: 1px solid #000;
            font: inherit;
        }
        #categorySearch input[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch select:not(:has(option)) {
            display: none;
        }
        a[href] {
            color: #2cafff;
        }
        #loading {
            text-align: center;
            padding: 20px;
        }
        .loading-details {
            font-size: 14px;
            opacity: 0.85;
            margin-top: 8px;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .loading-progress {
            width: 100%;
            height: 4px;
            background: #38444D;
            border-radius: 2px;
            margin: 12px 0;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background: #2cafff;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .error-message {
            background: #5c2626;
            border: 1px solid #8b3a3a;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            display: none;
        }
        .error-message.visible {
            display: block;
        }
        .retry-btn {
            background: #2cafff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
        }
        .retry-btn:hover {
            background: #1a9ae8;
        }
    </style>
</head>
<body>
    <p id="loading">Loading...</p>
    <div class="posts" data-testid="posts" role="feed" aria-label="Wikipedia article feed"></div>
    <aside class="stats" data-testid="stats" aria-live="polite" aria-label="Category engagement scores"></aside>
    <div id="startScreen" popover="manual">
        <div>
            <h1>Xikipedia</h1>
            <h2 style="font-size: 100%;opacity:0.85;font-style:italic">
                by <a href="https://lyra.horse">rebane2001</a>
            </h2>
        </div>
        <p>
            <strong>Xikipedia</strong> is a pseudo social media feed that algorithmically shows you content from 
            <a href="https://simple.wikipedia.org/">Simple Wikipedia</a>. It is made as a demonstration of how 
            even a basic non-ML algorithm with no data from other users can quickly learn what you engage with 
            to suggest you more similar content. No data is collected or shared here, the algorithm runs locally 
            and the data disappears once you refresh or close the tab.
        </p>
        <p>
            Original source on <a href="https://github.com/rebane2001/xikipedia">GitHub</a>.
            Recreation hosted on Cloudflare Workers.
        </p>
        <p style="font-weight: 600;margin:0">Pick some categories to get started (optional)</p>
        <div id="categoryPickList"></div>
        <p style="font-weight: 600;margin:0">Or add your own</p>
        <div id="categorySearch" style="display:flex;flex-direction:column">
            <input placeholder="Estonia..." disabled data-testid="category-search-input" aria-label="Search for categories">
            <select size="5" data-testid="category-search-select" aria-label="Category search results"></select>
        </div>
        <p style="margin-top:auto">
            Since the content and images shown is from random Wikipedia articles, you will likely see 
            NSFW content. Please only continue if you're an adult.
        </p>
        <div class="loading-progress" id="loadingProgress" style="display:none">
            <div class="loading-progress-bar" id="loadingProgressBar"></div>
        </div>
        <div class="loading-details" id="loadingDetails"></div>
        <div class="error-message" id="errorMessage">
            <strong>Failed to load data</strong>
            <p id="errorText">Network error occurred.</p>
            <button class="retry-btn" id="retryBtn">Try again</button>
        </div>
        <button id="startBtn" disabled data-testid="start-button" aria-label="Start browsing Xikipedia (adult content warning)">I'm an adult, continue</button>
    </div>
<script>
    // ============================================
    // Xikipedia - Wikipedia as a Social Media Feed
    // Original by rebane2001 (https://lyra.horse)
    // Recreation for Cloudflare Workers deployment
    // ============================================

    const pagesArr = [];
    let noPageMaps = {};
    const recursiveCache = new Map();
    const categoryScores = {
        "given names": -1000,
        "surnames": -1000,
    };
    const defaultCategories = [
        "nature", "science", "animals", "anthropology", "places", 
        "sociology", "art", "mathematics", "games", "technology", 
        "music", "human sexuality"
    ];
    let postsWithoutLike = 0;
    const DATA_SIZE = 225690064;

    // DOM Elements
    const startBtn = document.getElementById("startBtn");
    const startScreen = document.getElementById("startScreen");
    const categoryPickList = document.getElementById("categoryPickList");
    const categorySearch = document.getElementById("categorySearch");
    const categorySearchInput = categorySearch.querySelector("input");
    const categorySearchSelect = categorySearch.querySelector("select");

    // Category search functionality
    categorySearchInput.oninput = () => {
        const searchText = categorySearchInput.value;
        if (!searchText.length) {
            categorySearchSelect.innerText = "";
            return;
        }
        const searchTarget = [
            ...pagesArr.map(e => e.title.toLowerCase()), 
            ...Object.values(noPageMaps).map(e => e.toLowerCase())
        ];
        let results = searchTarget
            .filter(e => e.startsWith(searchText.toLowerCase()))
            .slice(0, 100);
        if (results.length < 100) {
            results = [
                ...results, 
                ...searchTarget
                    .filter(e => e.includes(searchText.toLowerCase()) && !results.includes(e))
                    .slice(0, 100 - results.length)
            ];
        }
        if (results.length === 100) {
            results.push("...");
        }
        categorySearchSelect.innerText = "";
        results.forEach(e => {
            const option = document.createElement("option");
            option.innerText = `${e.slice(0, 1).toUpperCase()}${e.slice(1).toLowerCase()}`;
            option.value = e;
            categorySearchSelect.appendChild(option);
        });
    };

    categorySearchSelect.oninput = () => {
        if (!categorySearchSelect.value || categorySearchSelect.value === "...") return;
        addPickableCategory(categorySearchSelect.value, true);
    };

    // Recursive category expansion with memoization
    function recursiveCategories(subCategories, categories, depth) {
        const allCategories = new Set(categories);
        categories.forEach(e => {
            const cat = e?.toLowerCase?.();
            if (!cat) return;
            const subs = subCategories[cat] ?? [];
            if (!subs.length) return;
            
            let cacheValue = recursiveCache.get(cat);
            if (!cacheValue) {
                recursiveCache.set(cat, -1);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            } else if (cacheValue === -1) {
                recursiveCache.set(cat, []);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            }
            allCategories.add(...subs);
            allCategories.add(...cacheValue);
        });
        return new Set([...allCategories].map(e => e?.toLowerCase?.() || e));
    }

    // Convert category ID to display name
    function convertCat(cat) {
        if (cat.startsWith("p:")) {
            cat = cat.slice(2);
            return pagesArr.find(e => e.id == cat)?.title ?? noPageMaps[cat] ?? cat;
        }
        return cat;
    }

    // Update the stats sidebar
    function updateEngagement() {
        const sorted = Object.entries(categoryScores)
            .filter(e => e[1])
            .sort((a, b) => b[1] - a[1]);
        const top10 = sorted.slice(0, 10);
        const bottom10 = sorted.slice(sorted.length - 10);
        document.querySelector(".stats").innerText = 
            top10.map(([k, v]) => `${convertCat(k)}: ${v}`).join("\n") + 
            "\n...\n" + 
            bottom10.map(([k, v]) => `${convertCat(k)}: ${v}`).join("\n");
    }

    // Apply engagement score to post categories
    function engagePost(post, amount) {
        post.allCategories.forEach(e => {
            categoryScores[e] = (categoryScores[e] ?? 0) + amount;
        });
        return amount;
    }

    // Show full-size image in popover
    function showPic(imgName) {
        const fullImg = document.createElement("img");
        fullImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${imgName.replace(/ /g, '_')}`;
        fullImg.popover = "auto";
        fullImg.classList.add("fullImg");
        document.body.appendChild(fullImg);
        fullImg.showPopover();
        fullImg.ontoggle = (e) => e.newState === "open" || fullImg.remove();
        fullImg.onclick = () => fullImg.hidePopover();
    }

    // Create and render a post element
    function createNextPost() {
        const nextPost = getNextPost();
        const postDiv = document.createElement("article");
        const postTitle = document.createElement("h1");
        const postP = document.createElement("p");
        const postYes = document.createElement("button");

        postDiv.classList.add("post");
        postDiv.dataset.testid = "post";
        postDiv.dataset.title = nextPost.title;
        postDiv.setAttribute("tabindex", "0");
        postDiv.setAttribute("aria-label", `Article: ${nextPost.title}. Press Enter to open on Wikipedia.`);

        const openWikipedia = () => {
            window.open(`https://simple.wikipedia.org/wiki/${nextPost.title.replace(/ /g, '_')}`);
            if (!postDiv.dataset.engaged) {
                postDiv.dataset.engaged = engagePost(nextPost, 75);
            }
        };

        postDiv.onclick = openWikipedia;

        postDiv.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openWikipedia();
            }
        };

        postTitle.innerText = nextPost.title;
        postP.innerText = nextPost.text;
        postYes.innerText = "Like";
        postYes.dataset.testid = "like-button";
        postYes.setAttribute("aria-label", `Like this article: ${nextPost.title}`);
        postYes.setAttribute("aria-pressed", "false");

        const handleLike = (e) => {
            postYes.dataset.liked = "true";
            postYes.setAttribute("aria-pressed", "true");
            if (!postYes.dataset.engaged) {
                postYes.dataset.engaged = engagePost(nextPost, 50 + postsWithoutLike * 4);
            }
            postsWithoutLike = 0;
            setTimeout(updateEngagement, 100);
            e.stopPropagation();
        };

        postYes.onclick = handleLike;

        postDiv.appendChild(postTitle);
        postDiv.appendChild(postP);
        
        if (nextPost.thumb) {
            const postImg = document.createElement("img");
            postImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${nextPost.thumb.replace(/ /g, '_')}&width=512`;
            postImg.classList.add("media");
            postImg.loading = "eager";
            postImg.onerror = () => postImg.remove();
            postImg.onclick = (e) => {
                showPic(nextPost.thumb);
                if (!postImg.dataset.engaged) {
                    postImg.dataset.engaged = engagePost(nextPost, 100);
                }
                e.stopPropagation();
            };
            postDiv.appendChild(postImg);
        }
        
        postDiv.appendChild(postYes);
        engagePost(nextPost, -5);
        postsWithoutLike++;
        document.querySelector(".posts").appendChild(postDiv);
    }

    // Get next post using the scoring algorithm
    function getNextPost() {
        const potentialPosts = [...Array(10000)]
            .map(() => pagesArr[Math.floor(Math.random() * pagesArr.length)])
            .map(post => {
                const initialScore = (post.thumb ? 5 : 0) + (3 ** (post.seen ?? 0) - 1) * -50000;
                const postScore = [...post.allCategories].reduce(
                    (sum, cat) => sum + (categoryScores[cat] ?? 0), 
                    initialScore
                );
                post.score = postScore;
                return post;
            });

        let highestScore = -Infinity;
        let bestPost = potentialPosts[0];

        if (Math.random() < 0.4) {
            // Weighted random selection
            const minScore = Math.min(...potentialPosts.map(e => e.score));
            const maxScore = potentialPosts.reduce((sum, post) => sum + post.score - minScore, 0);
            const targetScore = Math.random() * maxScore;
            let scoreCount = 0;

            while (scoreCount < targetScore && potentialPosts.length) {
                const potentialPost = potentialPosts.pop();
                bestPost = potentialPost;
                scoreCount += potentialPost.score - minScore;
            }
        } else if (Math.random() > 0.3) {
            // Highest score selection
            potentialPosts.forEach(post => {
                if (post.score > highestScore) {
                    bestPost = post;
                    highestScore = post.score;
                }
            });
        }
        
        bestPost.seen = (bestPost.seen ?? 0) + 1;
        return bestPost;
    }

    // Render loop - creates posts as user scrolls
    function render() {
        if (document.documentElement.scrollHeight < scrollY + innerHeight + 1500) {
            createNextPost();
        }
        requestAnimationFrame(render);
    }

    // Add a category picker button
    function addPickableCategory(cat, checked) {
        const escapedCat = cat.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        if (document.querySelector(`.categoryPicker input[data-category="${escapedCat}"]`)) {
            return;
        }
        const picker = document.createElement("label");
        const check = document.createElement("input");
        const labelText = `${cat.slice(0, 1).toUpperCase()}${cat.slice(1).toLowerCase()}`;
        check.type = "checkbox";
        picker.innerText = labelText;
        picker.appendChild(check);
        picker.classList.add("categoryPicker");
        check.dataset.category = cat;
        if (checked) check.checked = true;
        categoryPickList.appendChild(picker);
    }

    // Stream reader helper
    async function* streamToAsyncIterable(stream) {
        const reader = stream.getReader();
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) return;
                yield value;
            }
        } finally {
            reader.releaseLock();
        }
    }

    // Format bytes to human readable
    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Format seconds to human readable time
    function formatTime(seconds) {
        if (seconds < 60) return Math.ceil(seconds) + 's';
        const mins = Math.floor(seconds / 60);
        const secs = Math.ceil(seconds % 60);
        return `${mins}m ${secs}s`;
    }

    // Fetch file with progress tracking and retry logic
    async function getFileWithProgress(url, retryCount = 0) {
        const MAX_RETRIES = 3;
        const loadingProgress = document.getElementById('loadingProgress');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const loadingDetails = document.getElementById('loadingDetails');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const retryBtn = document.getElementById('retryBtn');

        loadingProgress.style.display = 'block';
        errorMessage.classList.remove('visible');

        try {
            const resp = await fetch(url, { cache: "force-cache" });

            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            }

            let responseSize = 0;
            const bytes = new Uint8Array(DATA_SIZE);
            const startTime = Date.now();
            let speedSamples = [];
            let lastSampleTime = startTime;
            let lastSampleSize = 0;

            for await (const chunk of streamToAsyncIterable(resp.body)) {
                bytes.set(chunk, responseSize);
                responseSize += chunk.length;

                const now = Date.now();
                const percent = Math.floor(responseSize / DATA_SIZE * 100);

                // Calculate speed every 500ms
                if (now - lastSampleTime >= 500) {
                    const bytesInInterval = responseSize - lastSampleSize;
                    const secondsInInterval = (now - lastSampleTime) / 1000;
                    const currentSpeed = bytesInInterval / secondsInInterval;

                    speedSamples.push(currentSpeed);
                    if (speedSamples.length > 5) speedSamples.shift();

                    lastSampleTime = now;
                    lastSampleSize = responseSize;
                }

                // Update UI
                loadingProgressBar.style.width = percent + '%';
                startBtn.innerText = `Downloading... ${percent}%`;

                if (speedSamples.length > 0) {
                    const avgSpeed = speedSamples.reduce((a, b) => a + b, 0) / speedSamples.length;
                    const remaining = DATA_SIZE - responseSize;
                    const eta = remaining / avgSpeed;
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)} · ${formatBytes(avgSpeed)}/s · ~${formatTime(eta)} remaining`;
                } else {
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)}`;
                }
            }

            loadingProgressBar.style.width = '100%';
            startBtn.innerText = `Download complete, processing...`;
            loadingDetails.innerText = '';
            await new Promise(requestAnimationFrame);
            await new Promise(requestAnimationFrame);
            return JSON.parse(new TextDecoder().decode(bytes));

        } catch (error) {
            console.error('Download failed:', error);

            if (retryCount < MAX_RETRIES) {
                const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                startBtn.innerText = `Connection lost, retrying in ${delay/1000}s...`;
                loadingDetails.innerText = `Attempt ${retryCount + 2} of ${MAX_RETRIES + 1}`;
                await new Promise(r => setTimeout(r, delay));
                return getFileWithProgress(url, retryCount + 1);
            }

            // All retries failed
            loadingProgress.style.display = 'none';
            loadingDetails.innerText = '';
            errorMessage.classList.add('visible');
            errorText.innerText = error.message || 'Network error. Please check your connection.';
            startBtn.innerText = 'Loading failed';

            // Return a promise that resolves when user clicks retry
            return new Promise((resolve) => {
                retryBtn.onclick = () => {
                    resolve(getFileWithProgress(url, 0));
                };
            });
        }
    }

    // Main initialization
    async function main() {
        startScreen.showPopover();
        defaultCategories.forEach(e => addPickableCategory(e));
        startBtn.innerText = "Xikipedia is loading... (downloading ~40MB of data)";
        
        const smoldata = await getFileWithProgress("smoldata.json");

        const subCategories = smoldata.subCategories;
        noPageMaps = smoldata.noPageMaps;
        delete smoldata.subCategories;
        delete smoldata.noPageMaps;

        let i = 0;
        const wikiLen = smoldata.pages.length;
        console.log(`Processing ${wikiLen} articles...`);
        const loading = document.querySelector("#loading");
        let lastFrame = Date.now();
        
        const loadingDetails = document.getElementById('loadingDetails');
        const loadingProgressBar = document.getElementById('loadingProgressBar');

        while (smoldata.pages.length) {
            const e = smoldata.pages.pop();
            const tempPage = {
                title: e[0],
                id: e[1],
                text: e[2],
                thumb: e[3],
                categories: e[4],
                links: e[5]
            };

            if (i % 1000 === 0 && Date.now() - lastFrame > 20) {
                const percent = (i / wikiLen * 100).toFixed(0);
                startBtn.innerText = `Processing articles... ${percent}%`;
                loadingProgressBar.style.width = percent + '%';
                loadingDetails.innerText = `${i.toLocaleString()} of ${wikiLen.toLocaleString()} articles`;
                await new Promise(r => requestAnimationFrame(r));
                lastFrame = Date.now();
            }
            i++;
            
            tempPage.allCategories = new Set(recursiveCategories(subCategories, [...tempPage.categories], 0));
            tempPage.allCategories.add(`p:${tempPage.id}`);
            tempPage.allCategories.add(...tempPage.links.map(e => `p:${e}`));
            pagesArr.push(tempPage);
        }
        
        loading.remove();
        document.getElementById('loadingProgress').style.display = 'none';
        document.getElementById('loadingDetails').innerText = `${wikiLen.toLocaleString()} articles ready`;
        startBtn.removeAttribute("disabled");
        categorySearchInput.removeAttribute("disabled");
        startBtn.innerText = "I'm an adult, continue";
        
        startBtn.onclick = () => {
            startScreen.hidePopover();
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                categoryScores[e.dataset.category] = defaultCategories.includes(e.dataset.category) ? 1000 : 5000;
            });
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                if (defaultCategories.includes(e.dataset.category)) return;
                const page = pagesArr.find(x => x.title.toLowerCase() === e.dataset.category);
                if (page) engagePost(page, 100);
            });
            startScreen.remove();
            requestAnimationFrame(render);
        };
    }

    window.onload = main;
</script>
</body>
</html>
