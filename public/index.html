<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Xikipedia</title>
    <meta property="og:url" content="https://xikipedia.emilycogsdill.com/">
    <meta property="og:title" content="Xikipedia">
    <meta name="description" content="Wikipedia you can doomscroll">
    <meta property="og:description" content="Wikipedia you can doomscroll">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta content="#38444D" name="theme-color">
    <link rel="icon" href="/favicon.ico">
    <style>
        :root {
            --bg-primary: #15202B;
            --bg-secondary: #1C2732;
            --bg-tertiary: #000;
            --text-primary: #FFF;
            --text-secondary: #8899aa;
            --border-color: #38444D;
            --accent-color: #2cafff;
        }

        :root.light-mode {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F7F9FA;
            --bg-tertiary: #EFF3F4;
            --text-primary: #0F1419;
            --text-secondary: #536471;
            --border-color: #EFF3F4;
            --accent-color: #1D9BF0;
        }

        html, body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: system-ui, sans-serif;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            justify-content: center;
        }
        .posts {
            max-width: 600px;
            width: 100vw;
            border: 1px solid var(--border-color);
            border-top: none;
            height: fit-content;
        }
        .posts:has(.post) {
            margin-bottom: 1000px;
        }
        .stats {
            max-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: fixed;
            left: calc(50% + 330px);
            top: 20px;
            padding: 8px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
        }
        @media (max-width: 1000px) {
            .stats {
                display: none;
            }
        }
        .post {
            padding: 12px 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: pointer;
        }
        .post:hover,
        .post:focus {
            background: var(--bg-secondary);
        }
        .post:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
        }
        .post h1 {
            font-size: 100%;
            margin: 0;
        }
        .post p {
            margin: 0;
            word-break: break-word;
        }
        .post button {
            align-self: end;
            margin: -4px;
            margin-top: 4px;
            padding: 4px;
            background: transparent;
            transition: background 0.2s, transform 0.2s cubic-bezier(.15,.67,0,1);
            border-radius: 64px;
            font-size: 0;
            border: 0;
            cursor: pointer;
        }
        .post button:hover:not([data-liked]) {
            background: rgba(255,255,255,0.13);
            transform: scale(1.1);
        }
        .post button:active:not([data-liked]),
        .post button:active {
            transform: scale(0.9);
        }
        .post button::after {
            font-size: 16px;
            display: block;
            width: 24px;
            height: 24px;
            margin-top: 1px;
            margin-bottom: -1px;
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="none" stroke="%2389A" stroke-linejoin="round"/></svg>');
        }
        .post button[data-liked]::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="red" stroke="red"/></svg>');
        }
        .post .share-btn::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16c-.8 0-1.5.3-2 .8l-7-4c.1-.3.1-.5.1-.8s0-.5-.1-.8l7-4c.5.5 1.2.8 2 .8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 .3 0 .5.1.8l-7 4c-.5-.5-1.2-.8-2-.8-1.7 0-3 1.3-3 3s1.3 3 3 3c.8 0 1.5-.3 2-.8l7 4c-.1.3-.1.5-.1.8 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z" fill="%2389A"/></svg>');
        }
        .post .share-btn.copied::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16c-.8 0-1.5.3-2 .8l-7-4c.1-.3.1-.5.1-.8s0-.5-.1-.8l7-4c.5.5 1.2.8 2 .8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 .3 0 .5.1.8l-7 4c-.5-.5-1.2-.8-2-.8-1.7 0-3 1.3-3 3s1.3 3 3 3c.8 0 1.5-.3 2-.8l7 4c-.1.3-.1.5-.1.8 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z" fill="%232cafff"/></svg>');
        }
        .post .button-row {
            align-self: end;
            display: flex;
            gap: 8px;
        }
        /* Double-tap like animation */
        @keyframes doubleTapLike {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .double-tap-heart {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 80px;
            height: 80px;
            pointer-events: none;
            animation: doubleTapLike 0.6s ease-out forwards;
            z-index: 10;
        }
        .post {
            position: relative;
        }
        .post img.media {
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: block;
            margin: 8px 0;
            max-width: min(512px, 100%);
            max-height: 330px;
            background: #FFF;
        }
        .fullImg {
            max-height: 95%;
            max-width: 95%;
            min-width: 25%;
            min-height: 25%;
        }
        body ::backdrop {
            background: rgba(0,0,0,0.6);
        }
        #startScreen {
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border: none;
            width: 90%;
            height: 90%;
            max-width: 600px;
            color: var(--text-primary);
            border-radius: 8px;
            padding: 32px;
            box-sizing: border-box;
        }
        #startScreen h1,
        #startScreen h2 {
            margin: 0;
        }
        #categoryPickList {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }
        .categoryPicker {
            border-radius: 100px;
            cursor: pointer;
            padding: 10px;
            display: inline-flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: inset 0px 0px 1.2px 0px #000;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .categoryPicker::after {
            content: "+";
            color: var(--accent-color);
            font-size: 150%;
            line-height: 0;
            margin-left: 8px;
        }
        .categoryPicker:hover,
        .categoryPicker:active {
            background: var(--border-color);
        }
        .categoryPicker:has(input:checked) {
            background: var(--text-primary);
            color: var(--bg-primary);
        }
        .categoryPicker:has(input:checked)::after {
            content: "âˆ’";
            color: var(--bg-primary);
        }
        .categoryPicker:has(input:focus-visible) {
            outline: 2px solid var(--accent-color);
        }
        .categoryPicker input {
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }
        #startBtn {
            border-radius: 32px;
            padding: 12px;
            background: var(--accent-color);
            color: #FFF;
            border: 1px solid var(--bg-tertiary);
            font: inherit;
            cursor: pointer;
        }
        #startBtn[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch {
            margin: 8px 0;
            gap: 8px;
        }
        #categorySearch input {
            border-radius: 32px;
            padding: 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--bg-tertiary);
            font: inherit;
        }
        #categorySearch input[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch select:not(:has(option)) {
            display: none;
        }
        a[href] {
            color: var(--accent-color);
        }
        #loading {
            text-align: center;
            padding: 20px;
        }
        .loading-details {
            font-size: 14px;
            opacity: 0.85;
            margin-top: 8px;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .loading-progress {
            width: 100%;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 12px 0;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .error-message {
            background: #5c2626;
            border: 1px solid #8b3a3a;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            display: none;
        }
        .error-message.visible {
            display: block;
        }
        .retry-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
        }
        .retry-btn:hover {
            background: #1a9ae8;
        }
        .recommendation-reason {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 4px 0 8px 0;
            font-style: italic;
        }
        #themeToggle {
            position: fixed;
            top: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }
        .session-stats {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
        }
        @media (max-width: 600px) {
            .session-stats { display: none; }
        }
        .data-freshness {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 4px 0;
        }
        .surprise-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font: inherit;
            cursor: pointer;
            margin: 8px 0;
        }
        .surprise-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        /* === Feature 2: Refresh button & pull-to-refresh === */
        .floating-btn {
            position: fixed;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #2cafff;
            border: none;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s, opacity 0.2s;
        }
        .floating-btn:hover {
            transform: scale(1.1);
        }
        .floating-btn:active {
            transform: scale(0.9);
        }
        #refreshBtn {
            right: 24px;
            bottom: 24px;
        }
        #refreshBtn::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M17.65 6.35A7.96 7.96 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" fill="white"/></svg>');
        }
        .pull-to-refresh-indicator {
            text-align: center;
            padding: 12px;
            color: #8899AA;
            font-size: 14px;
            transition: opacity 0.3s;
            overflow: hidden;
            height: 0;
        }
        .pull-to-refresh-indicator.active {
            height: auto;
        }
        .pull-to-refresh-indicator .spinner {
            display: inline-block;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <button id="themeToggle" aria-label="Toggle dark/light mode">&#127769;</button>
    <p id="loading">Loading...</p>
    <div class="posts" data-testid="posts" role="feed" aria-label="Wikipedia article feed"></div>
    <div id="sessionStats" class="session-stats">
        <span id="viewCount">0</span> viewed Â· <span id="likeCount">0</span> liked
    </div>
    <aside class="stats" data-testid="stats" aria-live="polite" aria-label="Category engagement scores"></aside>
    <button class="floating-btn" id="refreshBtn" aria-label="Refresh feed" style="display:none"></button>
    <div id="startScreen" popover="manual">
        <div>
            <h1>Xikipedia</h1>
            <h2 style="font-size: 100%;opacity:0.85;font-style:italic">
                by <a href="https://lyra.horse">rebane2001</a>
            </h2>
        </div>
        <p>
            <strong>Xikipedia</strong> is a pseudo social media feed that algorithmically shows you content from 
            <a href="https://simple.wikipedia.org/">Simple Wikipedia</a>. It is made as a demonstration of how 
            even a basic non-ML algorithm with no data from other users can quickly learn what you engage with 
            to suggest you more similar content. No data is collected or shared here, the algorithm runs locally 
            and the data disappears once you refresh or close the tab.
        </p>
        <p>
            Original source on <a href="https://github.com/rebane2001/xikipedia">GitHub</a>.
            Recreation hosted on Cloudflare Workers.
        </p>
        <p style="font-weight: 600;margin:0">Pick some categories to get started (optional)</p>
        <div id="categoryPickList"></div>
        <button id="surpriseMe" class="surprise-btn">ðŸŽ² Surprise me!</button>
        <p style="font-weight: 600;margin:0">Or add your own</p>
        <div id="categorySearch" style="display:flex;flex-direction:column">
            <input placeholder="Estonia..." disabled data-testid="category-search-input" aria-label="Search for categories">
            <select size="5" data-testid="category-search-select" aria-label="Category search results"></select>
        </div>
        <p style="margin-top:auto">
            Since the content and images shown is from random Wikipedia articles, you will likely see
            NSFW content. Please only continue if you're an adult.
        </p>
        <p class="data-freshness">Data last updated: <span id="lastUpdated">February 2026</span></p>
        <div class="loading-progress" id="loadingProgress" style="display:none">
            <div class="loading-progress-bar" id="loadingProgressBar"></div>
        </div>
        <div class="loading-details" id="loadingDetails"></div>
        <div class="error-message" id="errorMessage">
            <strong>Failed to load data</strong>
            <p id="errorText">Network error occurred.</p>
            <button class="retry-btn" id="retryBtn">Try again</button>
        </div>
        <button id="startBtn" disabled data-testid="start-button" aria-label="Start browsing Xikipedia (adult content warning)">I'm an adult, continue</button>
    </div>
<script>
    // ============================================
    // Xikipedia - Wikipedia as a Social Media Feed
    // Original by rebane2001 (https://lyra.horse)
    // Recreation for Cloudflare Workers deployment
    // ============================================

    // Theme toggle functionality
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.onclick = () => {
        document.documentElement.classList.toggle('light-mode');
        themeToggle.textContent = document.documentElement.classList.contains('light-mode') ? '\u2600\uFE0F' : '\uD83C\uDF19';
        localStorage.setItem('theme', document.documentElement.classList.contains('light-mode') ? 'light' : 'dark');
    };
    // Load saved theme
    if (localStorage.getItem('theme') === 'light') {
        document.documentElement.classList.add('light-mode');
        themeToggle.textContent = '\u2600\uFE0F';
    }

    const DATA_LAST_UPDATED = "February 2026";
    const pagesArr = [];
    let noPageMaps = {};
    const recursiveCache = new Map();

    // Session stats tracking
    let articlesViewed = 0;
    let articlesLiked = 0;
    let currentStreak = 0;
    let maxStreak = 0;

    const categoryScores = {
        "given names": -1000,
        "surnames": -1000,
    };
    const defaultCategories = [
        "nature", "science", "animals", "anthropology", "places", 
        "sociology", "art", "mathematics", "games", "technology", 
        "music", "human sexuality"
    ];
    let postsWithoutLike = 0;
    const DATA_SIZE = 225690064;

    // Double-tap detection state
    let lastTapTime = 0;
    let lastTapTarget = null;
    let singleTapTimer = null;

    // DOM Elements
    const startBtn = document.getElementById("startBtn");
    const startScreen = document.getElementById("startScreen");
    const categoryPickList = document.getElementById("categoryPickList");
    const categorySearch = document.getElementById("categorySearch");
    const categorySearchInput = categorySearch.querySelector("input");
    const categorySearchSelect = categorySearch.querySelector("select");

    // Category search functionality
    categorySearchInput.oninput = () => {
        const searchText = categorySearchInput.value;
        if (!searchText.length) {
            categorySearchSelect.innerText = "";
            return;
        }
        const searchTarget = [
            ...pagesArr.map(e => e.title.toLowerCase()), 
            ...Object.values(noPageMaps).map(e => e.toLowerCase())
        ];
        let results = searchTarget
            .filter(e => e.startsWith(searchText.toLowerCase()))
            .slice(0, 100);
        if (results.length < 100) {
            results = [
                ...results, 
                ...searchTarget
                    .filter(e => e.includes(searchText.toLowerCase()) && !results.includes(e))
                    .slice(0, 100 - results.length)
            ];
        }
        if (results.length === 100) {
            results.push("...");
        }
        categorySearchSelect.innerText = "";
        results.forEach(e => {
            const option = document.createElement("option");
            option.innerText = `${e.slice(0, 1).toUpperCase()}${e.slice(1).toLowerCase()}`;
            option.value = e;
            categorySearchSelect.appendChild(option);
        });
    };

    categorySearchSelect.oninput = () => {
        if (!categorySearchSelect.value || categorySearchSelect.value === "...") return;
        addPickableCategory(categorySearchSelect.value, true);
    };

    // Surprise me button handler
    document.getElementById('surpriseMe').onclick = () => {
        // Uncheck all current selections
        document.querySelectorAll('.categoryPicker input:checked').forEach(cb => cb.checked = false);

        // Pick 3-5 random categories from defaultCategories
        const shuffled = [...defaultCategories].sort(() => Math.random() - 0.5);
        const count = 3 + Math.floor(Math.random() * 3); // 3-5 categories
        const selected = shuffled.slice(0, count);

        // Check those categories
        selected.forEach(cat => {
            const checkbox = document.querySelector(`.categoryPicker input[data-category="${cat}"]`);
            if (checkbox) checkbox.checked = true;
        });
    };

    // Recursive category expansion with memoization
    function recursiveCategories(subCategories, categories, depth) {
        const allCategories = new Set(categories);
        categories.forEach(e => {
            const cat = e?.toLowerCase?.();
            if (!cat) return;
            const subs = subCategories[cat] ?? [];
            if (!subs.length) return;
            
            let cacheValue = recursiveCache.get(cat);
            if (!cacheValue) {
                recursiveCache.set(cat, -1);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            } else if (cacheValue === -1) {
                recursiveCache.set(cat, []);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            }
            allCategories.add(...subs);
            allCategories.add(...cacheValue);
        });
        return new Set([...allCategories].map(e => e?.toLowerCase?.() || e));
    }

    // Convert category ID to display name
    function convertCat(cat) {
        if (cat.startsWith("p:")) {
            cat = cat.slice(2);
            return pagesArr.find(e => e.id == cat)?.title ?? noPageMaps[cat] ?? cat;
        }
        return cat;
    }

    // Update the stats sidebar
    function updateEngagement() {
        const sorted = Object.entries(categoryScores)
            .filter(e => e[1])
            .sort((a, b) => b[1] - a[1]);
        const top10 = sorted.slice(0, 10);
        const bottom10 = sorted.slice(sorted.length - 10);
        document.querySelector(".stats").innerText = 
            top10.map(([k, v]) => `${convertCat(k)}: ${v}`).join("\n") + 
            "\n...\n" + 
            bottom10.map(([k, v]) => `${convertCat(k)}: ${v}`).join("\n");
    }

    // Apply engagement score to post categories
    function engagePost(post, amount) {
        post.allCategories.forEach(e => {
            categoryScores[e] = (categoryScores[e] ?? 0) + amount;
        });
        return amount;
    }

    // Update session stats display
    function updateSessionStats() {
        document.getElementById('viewCount').textContent = articlesViewed;
        document.getElementById('likeCount').textContent = articlesLiked;
    }

    // Show double-tap heart animation
    function showDoubleTapHeart(postDiv) {
        const heart = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        heart.setAttribute("viewBox", "0 0 24 24");
        heart.classList.add("double-tap-heart");
        heart.innerHTML = '<path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="red" stroke="red"/>';
        postDiv.appendChild(heart);
        heart.addEventListener("animationend", () => heart.remove());
    }

    // Show full-size image in popover
    function showPic(imgName) {
        const fullImg = document.createElement("img");
        fullImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${imgName.replace(/ /g, '_')}`;
        fullImg.popover = "auto";
        fullImg.classList.add("fullImg");
        document.body.appendChild(fullImg);
        fullImg.showPopover();
        fullImg.ontoggle = (e) => e.newState === "open" || fullImg.remove();
        fullImg.onclick = () => fullImg.hidePopover();
    }

    // Create and render a post element
    function createNextPost(specificPost = null) {
        const nextPost = specificPost || getNextPost();
        const postDiv = document.createElement("article");
        const postTitle = document.createElement("h1");
        const postP = document.createElement("p");
        const postYes = document.createElement("button");
        const shareBtn = document.createElement("button");
        const buttonRow = document.createElement("div");

        postDiv.classList.add("post");
        postDiv.dataset.testid = "post";
        postDiv.dataset.title = nextPost.title;
        postDiv.setAttribute("tabindex", "0");
        postDiv.setAttribute("aria-label", `Article: ${nextPost.title}. Press Enter to open on Wikipedia.`);

        const openWikipedia = () => {
            window.open(`https://simple.wikipedia.org/wiki/${nextPost.title.replace(/ /g, '_')}`);
            if (!postDiv.dataset.engaged) {
                postDiv.dataset.engaged = engagePost(nextPost, 75);
            }
        };

        postDiv.onclick = (e) => {
            const now = Date.now();

            // Fix race condition: clear timer if tapping a different post
            if (singleTapTimer && lastTapTarget !== postDiv) {
                clearTimeout(singleTapTimer);
                singleTapTimer = null;
            }

            const isDoubleTap = (now - lastTapTime < 300) && (lastTapTarget === postDiv);

            if (isDoubleTap) {
                // Double-tap detected - trigger like
                clearTimeout(singleTapTimer);
                singleTapTimer = null;

                // Only animate and like if not already liked
                if (!postYes.dataset.liked) {
                    postYes.click();
                    showDoubleTapHeart(postDiv);
                }

                // Reset tap tracking
                lastTapTime = 0;
                lastTapTarget = null;
            } else {
                // First tap - wait to see if it's a double-tap
                lastTapTime = now;
                lastTapTarget = postDiv;

                // Delay single-tap action to check for second tap
                singleTapTimer = setTimeout(() => {
                    if (lastTapTarget === postDiv) {
                        openWikipedia();
                    }
                    lastTapTime = 0;
                    lastTapTarget = null;
                }, 300);
            }
        };

        postDiv.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openWikipedia();
            }
        };

        postTitle.innerText = nextPost.title;
        postP.innerText = nextPost.text;
        postYes.innerText = "Like";
        postYes.dataset.testid = "like-button";
        postYes.setAttribute("aria-label", `Like this article: ${nextPost.title}`);
        postYes.setAttribute("aria-pressed", "false");

        const handleLike = (e) => {
            postYes.dataset.liked = "true";
            postYes.setAttribute("aria-pressed", "true");
            if (!postYes.dataset.engaged) {
                postYes.dataset.engaged = engagePost(nextPost, 50 + postsWithoutLike * 4);
                // Update session stats for likes
                articlesLiked++;
                currentStreak++;
                if (currentStreak > maxStreak) {
                    maxStreak = currentStreak;
                }
                updateSessionStats();
            }
            postsWithoutLike = 0;
            setTimeout(updateEngagement, 100);
            e.stopPropagation();
        };

        postYes.onclick = handleLike;

        shareBtn.innerText = "Share";
        shareBtn.classList.add("share-btn");
        shareBtn.dataset.testid = "share-button";
        shareBtn.setAttribute("aria-label", `Share this article: ${nextPost.title}`);

        shareBtn.onclick = (e) => {
            e.stopPropagation();
            const shareUrl = `${window.location.origin}${window.location.pathname}?article=${nextPost.id}`;
            navigator.clipboard.writeText(shareUrl)
                .then(() => {
                    shareBtn.classList.add("copied");
                    shareBtn.setAttribute("aria-label", "Link copied!");
                    setTimeout(() => {
                        shareBtn.classList.remove("copied");
                        shareBtn.setAttribute("aria-label", `Share this article: ${nextPost.title}`);
                    }, 2000);
                })
                .catch(() => {
                    // Fallback: show the URL in a prompt
                    prompt('Copy this link:', shareUrl);
                });
        };

        buttonRow.classList.add("button-row");

        postDiv.appendChild(postTitle);

        // Display recommendation reason if available
        if (nextPost.recommendedBecause && nextPost.recommendedBecause.length > 0) {
            const reasonP = document.createElement("p");
            reasonP.classList.add("recommendation-reason");
            reasonP.innerText = "Because you liked: " + nextPost.recommendedBecause.join(", ");
            postDiv.appendChild(reasonP);
        }

        postDiv.appendChild(postP);
        
        if (nextPost.thumb) {
            const postImg = document.createElement("img");
            postImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${nextPost.thumb.replace(/ /g, '_')}&width=512`;
            postImg.classList.add("media");
            postImg.loading = "eager";
            postImg.onerror = () => postImg.remove();
            postImg.onclick = (e) => {
                showPic(nextPost.thumb);
                if (!postImg.dataset.engaged) {
                    postImg.dataset.engaged = engagePost(nextPost, 100);
                }
                e.stopPropagation();
            };
            postDiv.appendChild(postImg);
        }

        buttonRow.appendChild(shareBtn);
        buttonRow.appendChild(postYes);
        postDiv.appendChild(buttonRow);
        engagePost(nextPost, -5);
        postsWithoutLike++;
        document.querySelector(".posts").appendChild(postDiv);

        // Update session stats
        articlesViewed++;
        updateSessionStats();
    }

    // Get next post using the scoring algorithm
    function getNextPost() {
        const potentialPosts = [...Array(10000)]
            .map(() => pagesArr[Math.floor(Math.random() * pagesArr.length)])
            .map(post => {
                const initialScore = (post.thumb ? 5 : 0) + (3 ** (post.seen ?? 0) - 1) * -50000;
                const postScore = [...post.allCategories].reduce(
                    (sum, cat) => sum + (categoryScores[cat] ?? 0),
                    initialScore
                );
                post.score = postScore;
                return post;
            });

        let highestScore = -Infinity;
        let bestPost = potentialPosts[0];

        if (Math.random() < 0.4) {
            // Weighted random selection
            const minScore = Math.min(...potentialPosts.map(e => e.score));
            const maxScore = potentialPosts.reduce((sum, post) => sum + post.score - minScore, 0);
            const targetScore = Math.random() * maxScore;
            let scoreCount = 0;

            while (scoreCount < targetScore && potentialPosts.length) {
                const potentialPost = potentialPosts.pop();
                bestPost = potentialPost;
                scoreCount += potentialPost.score - minScore;
            }
        } else if (Math.random() > 0.3) {
            // Highest score selection
            potentialPosts.forEach(post => {
                if (post.score > highestScore) {
                    bestPost = post;
                    highestScore = post.score;
                }
            });
        }

        bestPost.seen = (bestPost.seen ?? 0) + 1;

        // Track top contributing categories for transparency
        const categoryContributions = [...bestPost.allCategories]
            .map(cat => ({ cat, score: categoryScores[cat] || 0 }))
            .filter(c => c.score > 0)  // Only positive contributions
            .sort((a, b) => b.score - a.score)
            .slice(0, 3);

        if (categoryContributions.length > 0) {
            bestPost.recommendedBecause = categoryContributions.map(c => convertCat(c.cat));
        } else {
            bestPost.recommendedBecause = null;
        }

        return bestPost;
    }

    // Render loop - creates posts as user scrolls
    function render() {
        if (document.documentElement.scrollHeight < scrollY + innerHeight + 1500) {
            createNextPost();
        }
        requestAnimationFrame(render);
    }

    // Add a category picker button
    function addPickableCategory(cat, checked) {
        const escapedCat = cat.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        if (document.querySelector(`.categoryPicker input[data-category="${escapedCat}"]`)) {
            return;
        }
        const picker = document.createElement("label");
        const check = document.createElement("input");
        const labelText = `${cat.slice(0, 1).toUpperCase()}${cat.slice(1).toLowerCase()}`;
        check.type = "checkbox";
        picker.innerText = labelText;
        picker.appendChild(check);
        picker.classList.add("categoryPicker");
        check.dataset.category = cat;
        if (checked) check.checked = true;
        categoryPickList.appendChild(picker);
    }

    // Stream reader helper
    async function* streamToAsyncIterable(stream) {
        const reader = stream.getReader();
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) return;
                yield value;
            }
        } finally {
            reader.releaseLock();
        }
    }

    // Format bytes to human readable
    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Format seconds to human readable time
    function formatTime(seconds) {
        if (seconds < 60) return Math.ceil(seconds) + 's';
        const mins = Math.floor(seconds / 60);
        const secs = Math.ceil(seconds % 60);
        return `${mins}m ${secs}s`;
    }

    // Fetch file with progress tracking and retry logic
    async function getFileWithProgress(url, retryCount = 0) {
        const MAX_RETRIES = 3;
        const loadingProgress = document.getElementById('loadingProgress');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const loadingDetails = document.getElementById('loadingDetails');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const retryBtn = document.getElementById('retryBtn');

        loadingProgress.style.display = 'block';
        errorMessage.classList.remove('visible');

        try {
            const resp = await fetch(url, { cache: "force-cache" });

            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            }

            let responseSize = 0;
            const bytes = new Uint8Array(DATA_SIZE);
            const startTime = Date.now();
            let speedSamples = [];
            let lastSampleTime = startTime;
            let lastSampleSize = 0;

            for await (const chunk of streamToAsyncIterable(resp.body)) {
                bytes.set(chunk, responseSize);
                responseSize += chunk.length;

                const now = Date.now();
                const percent = Math.floor(responseSize / DATA_SIZE * 100);

                // Calculate speed every 500ms
                if (now - lastSampleTime >= 500) {
                    const bytesInInterval = responseSize - lastSampleSize;
                    const secondsInInterval = (now - lastSampleTime) / 1000;
                    const currentSpeed = bytesInInterval / secondsInInterval;

                    speedSamples.push(currentSpeed);
                    if (speedSamples.length > 5) speedSamples.shift();

                    lastSampleTime = now;
                    lastSampleSize = responseSize;
                }

                // Update UI
                loadingProgressBar.style.width = percent + '%';
                startBtn.innerText = `Downloading... ${percent}%`;

                if (speedSamples.length > 0) {
                    const avgSpeed = speedSamples.reduce((a, b) => a + b, 0) / speedSamples.length;
                    const remaining = DATA_SIZE - responseSize;
                    const eta = remaining / avgSpeed;
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)} Â· ${formatBytes(avgSpeed)}/s Â· ~${formatTime(eta)} remaining`;
                } else {
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)}`;
                }
            }

            loadingProgressBar.style.width = '100%';
            startBtn.innerText = `Download complete, processing...`;
            loadingDetails.innerText = '';
            await new Promise(requestAnimationFrame);
            await new Promise(requestAnimationFrame);
            return JSON.parse(new TextDecoder().decode(bytes.subarray(0, responseSize)));

        } catch (error) {
            console.error('Download failed:', error);

            if (retryCount < MAX_RETRIES) {
                const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                startBtn.innerText = `Connection lost, retrying in ${delay/1000}s...`;
                loadingDetails.innerText = `Attempt ${retryCount + 2} of ${MAX_RETRIES + 1}`;
                await new Promise(r => setTimeout(r, delay));
                return getFileWithProgress(url, retryCount + 1);
            }

            // All retries failed
            loadingProgress.style.display = 'none';
            loadingDetails.innerText = '';
            errorMessage.classList.add('visible');
            errorText.innerText = error.message || 'Network error. Please check your connection.';
            startBtn.innerText = 'Loading failed';

            // Return a promise that resolves when user clicks retry
            return new Promise((resolve) => {
                retryBtn.onclick = () => {
                    resolve(getFileWithProgress(url, 0));
                };
            });
        }
    }

    // ============================================
    // Feature 2: Feed Refresh
    // ============================================

    function refreshFeed() {
        // Clear all posts from DOM
        const postsContainer = document.querySelector(".posts");
        postsContainer.innerHTML = "";
        // Reset seen counters and stale recommendation reasons
        pagesArr.forEach(p => { delete p.seen; delete p.recommendedBecause; });
        // Reset like streak counter
        postsWithoutLike = 0;
        // Scroll to top
        window.scrollTo(0, 0);
        // The render loop is already running via rAF, new posts auto-generate
    }

    // Pull-to-refresh state
    let pullStartY = 0;
    let pullDist = 0;
    let isPulling = false;
    const PULL_THRESHOLD = 80;

    function initPullToRefresh() {
        const postsContainer = document.querySelector(".posts");

        // Create pull indicator element
        const indicator = document.createElement("div");
        indicator.classList.add("pull-to-refresh-indicator");
        indicator.id = "pullIndicator";
        indicator.innerHTML = '<span class="spinner">â†»</span> Pull to refresh';
        postsContainer.parentNode.insertBefore(indicator, postsContainer);

        postsContainer.addEventListener("touchstart", (e) => {
            if (window.scrollY <= 0) {
                pullStartY = e.touches[0].clientY;
                isPulling = true;
            }
        }, { passive: true });

        postsContainer.addEventListener("touchmove", (e) => {
            if (!isPulling) return;
            pullDist = e.touches[0].clientY - pullStartY;
            if (pullDist < 0) pullDist = 0;
            if (pullDist > 0 && window.scrollY <= 0) {
                e.preventDefault();
                indicator.classList.add("active");
                const progress = Math.min(pullDist / PULL_THRESHOLD, 1);
                indicator.style.height = (progress * 48) + "px";
                indicator.style.opacity = progress;
                if (pullDist >= PULL_THRESHOLD) {
                    indicator.innerHTML = '<span class="spinner">â†»</span> Release to refresh';
                } else {
                    indicator.innerHTML = '<span>â†“</span> Pull to refresh';
                }
            }
        }, { passive: false });

        postsContainer.addEventListener("touchend", () => {
            if (isPulling && pullDist >= PULL_THRESHOLD) {
                indicator.innerHTML = '<span class="spinner">â†»</span> Refreshing...';
                setTimeout(() => {
                    refreshFeed();
                    indicator.classList.remove("active");
                    indicator.style.height = "0";
                    indicator.style.opacity = "0";
                }, 300);
            } else {
                indicator.classList.remove("active");
                indicator.style.height = "0";
                indicator.style.opacity = "0";
            }
            isPulling = false;
            pullDist = 0;
        }, { passive: true });
    }

    // Main initialization
    async function main() {
        startScreen.showPopover();
        defaultCategories.forEach(e => addPickableCategory(e));
        startBtn.innerText = "Xikipedia is loading... (downloading ~40MB of data)";
        
        const smoldata = await getFileWithProgress("smoldata.json");

        const subCategories = smoldata.subCategories;
        noPageMaps = smoldata.noPageMaps;
        delete smoldata.subCategories;
        delete smoldata.noPageMaps;

        let i = 0;
        const wikiLen = smoldata.pages.length;
        console.log(`Processing ${wikiLen} articles...`);
        const loading = document.querySelector("#loading");
        let lastFrame = Date.now();

        const loadingDetails = document.getElementById('loadingDetails');
        const loadingProgressBar = document.getElementById('loadingProgressBar');

        let filteredCount = 0;

        while (smoldata.pages.length) {
            const e = smoldata.pages.pop();

            // Skip articles with very short text (less than 100 chars)
            if (e[2] && e[2].length < 100) {
                filteredCount++;
                i++;
                continue;
            }

            const tempPage = {
                title: e[0],
                id: e[1],
                text: e[2],
                thumb: e[3],
                categories: e[4],
                links: e[5]
            };

            if (i % 1000 === 0 && Date.now() - lastFrame > 20) {
                const percent = (i / wikiLen * 100).toFixed(0);
                startBtn.innerText = `Processing articles... ${percent}%`;
                loadingProgressBar.style.width = percent + '%';
                loadingDetails.innerText = `${i.toLocaleString()} of ${wikiLen.toLocaleString()} articles`;
                await new Promise(r => requestAnimationFrame(r));
                lastFrame = Date.now();
            }
            i++;
            
            tempPage.allCategories = new Set(recursiveCategories(subCategories, [...tempPage.categories], 0));
            tempPage.allCategories.add(`p:${tempPage.id}`);
            tempPage.allCategories.add(...tempPage.links.map(e => `p:${e}`));
            pagesArr.push(tempPage);
        }

        console.log(`Filtered ${filteredCount} short articles (less than 100 characters)`);

        loading.remove();
        document.getElementById('loadingProgress').style.display = 'none';
        document.getElementById('loadingDetails').innerText = `${wikiLen.toLocaleString()} articles ready`;
        startBtn.removeAttribute("disabled");
        categorySearchInput.removeAttribute("disabled");
        startBtn.innerText = "I'm an adult, continue";
        
        // Check for shared article URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const sharedArticleId = urlParams.get('article');
        let sharedArticle = null;
        if (sharedArticleId) {
            sharedArticle = pagesArr.find(p => p.id == sharedArticleId);
            if (!sharedArticle) {
                // Article not found - log warning
                console.warn('Shared article not found:', sharedArticleId);
            }
            // Clear the URL parameter
            window.history.replaceState({}, '', window.location.pathname);
        }

        startBtn.onclick = () => {
            startScreen.hidePopover();
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                categoryScores[e.dataset.category] = defaultCategories.includes(e.dataset.category) ? 1000 : 5000;
            });
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                if (defaultCategories.includes(e.dataset.category)) return;
                const page = pagesArr.find(x => x.title.toLowerCase() === e.dataset.category);
                if (page) engagePost(page, 100);
            });
            startScreen.remove();

            // Show floating refresh button and init pull-to-refresh
            document.getElementById("refreshBtn").style.display = "flex";
            document.getElementById("refreshBtn").onclick = (e) => {
                e.stopPropagation();
                refreshFeed();
            };
            initPullToRefresh();

            // If there's a shared article, show it first
            if (sharedArticle) {
                sharedArticle.seen = (sharedArticle.seen ?? 0) + 1;
                createNextPost(sharedArticle);
            }
            requestAnimationFrame(render);
        };
    }

    window.onload = main;
</script>
</body>
</html>
