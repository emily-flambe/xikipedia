<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Xikipedia</title>
    <meta property="og:url" content="https://xikipedia.emilycogsdill.com/">
    <meta property="og:title" content="Xikipedia">
    <meta name="description" content="Wikipedia you can doomscroll">
    <meta property="og:description" content="Wikipedia you can doomscroll">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta content="#38444D" name="theme-color">
    <link rel="icon" href="/favicon.ico">
    <style>
        :root {
            --bg-primary: #15202B;
            --bg-secondary: #1C2732;
            --bg-tertiary: #000;
            --text-primary: #FFF;
            --text-secondary: #8899aa;
            --border-color: #38444D;
            --accent-color: #2cafff;
        }

        :root.light-mode {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F7F9FA;
            --bg-tertiary: #EFF3F4;
            --text-primary: #0F1419;
            --text-secondary: #536471;
            --border-color: #EFF3F4;
            --accent-color: #1D9BF0;
        }

        html, body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: system-ui, sans-serif;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            justify-content: center;
        }
        .posts {
            max-width: 600px;
            width: 100vw;
            border: 1px solid var(--border-color);
            border-top: none;
            height: fit-content;
            padding-top: env(safe-area-inset-top, 0px);
        }
        @media (max-width: 650px) {
            .posts {
                max-width: 100%;
                border-left: none;
                border-right: none;
            }
        }
        .posts:has(.post) {
            margin-bottom: 1000px;
        }
        .stats {
            max-width: 300px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: fixed;
            right: -320px;
            top: 0;
            height: 100%;
            width: 300px;
            padding: 16px;
            padding-top: 48px;
            font-family: monospace;
            font-size: 12px;
            background: var(--bg-primary);
            z-index: 200;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .stats.open {
            right: 0;
        }
        .post {
            padding: 12px 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: pointer;
        }
        .post:hover,
        .post:focus {
            background: var(--bg-secondary);
        }
        .post:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
        }
        .post h1 {
            font-size: 100%;
            margin: 0;
        }
        .post p {
            margin: 0;
            word-break: break-word;
        }
        .post button:not(.feedback-btn) {
            align-self: end;
            margin: -4px;
            margin-top: 4px;
            padding: 4px;
            background: transparent;
            transition: background 0.2s, transform 0.2s cubic-bezier(.15,.67,0,1);
            border-radius: 64px;
            font-size: 0;
            border: 0;
            cursor: pointer;
        }
        .post button:not(.feedback-btn):hover:not([data-liked]) {
            background: rgba(255,255,255,0.13);
            transform: scale(1.1);
        }
        .post button:not(.feedback-btn):active:not([data-liked]),
        .post button:not(.feedback-btn):active {
            transform: scale(0.9);
        }
        .post button:not(.feedback-btn)::after {
            font-size: 16px;
            display: block;
            width: 24px;
            height: 24px;
            margin-top: 1px;
            margin-bottom: -1px;
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="none" stroke="%2389A" stroke-linejoin="round"/></svg>');
        }
        .post button:not(.feedback-btn)[data-liked]::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="red" stroke="red"/></svg>');
        }
        .post button.share-btn::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16c-.8 0-1.5.3-2 .8l-7-4c.1-.3.1-.5.1-.8s0-.5-.1-.8l7-4c.5.5 1.2.8 2 .8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 .3 0 .5.1.8l-7 4c-.5-.5-1.2-.8-2-.8-1.7 0-3 1.3-3 3s1.3 3 3 3c.8 0 1.5-.3 2-.8l7 4c-.1.3-.1.5-.1.8 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z" fill="%2389A"/></svg>');
        }
        .post button.share-btn.copied::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16c-.8 0-1.5.3-2 .8l-7-4c.1-.3.1-.5.1-.8s0-.5-.1-.8l7-4c.5.5 1.2.8 2 .8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 .3 0 .5.1.8l-7 4c-.5-.5-1.2-.8-2-.8-1.7 0-3 1.3-3 3s1.3 3 3 3c.8 0 1.5-.3 2-.8l7 4c-.1.3-.1.5-.1.8 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z" fill="%232cafff"/></svg>');
        }
        .post .button-row {
            align-self: stretch;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        /* Double-tap like animation */
        @keyframes doubleTapLike {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .double-tap-heart {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 80px;
            height: 80px;
            pointer-events: none;
            animation: doubleTapLike 0.6s ease-out forwards;
            z-index: 10;
        }
        .post {
            position: relative;
        }
        .post img.media {
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: block;
            margin: 8px 0;
            max-width: min(512px, 100%);
            max-height: 330px;
            background: #FFF;
        }
        .fullImg {
            max-height: 95%;
            max-width: 95%;
            min-width: 25%;
            min-height: 25%;
        }
        body ::backdrop {
            background: rgba(0,0,0,0.6);
        }
        #startScreen {
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border: none;
            width: 90%;
            height: 90%;
            max-width: 600px;
            color: var(--text-primary);
            border-radius: 8px;
            padding: 32px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        #startScreen h1,
        #startScreen h2 {
            margin: 0;
        }
        #categoryPickList {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }
        .categoryPicker {
            border-radius: 100px;
            cursor: pointer;
            padding: 10px;
            display: inline-flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: inset 0px 0px 1.2px 0px #000;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .categoryPicker::after {
            content: "+";
            color: var(--accent-color);
            font-size: 150%;
            line-height: 0;
            margin-left: 8px;
        }
        .categoryPicker:hover,
        .categoryPicker:active {
            background: var(--border-color);
        }
        .categoryPicker:has(input:checked) {
            background: var(--text-primary);
            color: var(--bg-primary);
        }
        .categoryPicker:has(input:checked)::after {
            content: "‚àí";
            color: var(--bg-primary);
        }
        .categoryPicker:has(input:focus-visible) {
            outline: 2px solid var(--accent-color);
        }
        .categoryPicker input {
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }
        #startBtn {
            border-radius: 32px;
            padding: 12px;
            background: var(--accent-color);
            color: #FFF;
            border: 1px solid var(--bg-tertiary);
            font: inherit;
            cursor: pointer;
        }
        #startBtn[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch {
            margin: 8px 0;
            gap: 8px;
        }
        #categorySearch input {
            border-radius: 32px;
            padding: 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--bg-tertiary);
            font: inherit;
        }
        #categorySearch input[disabled] {
            background: #557;
            cursor: not-allowed;
        }
        #categorySearch select:not(:has(option)) {
            display: none;
        }
        a[href] {
            color: var(--accent-color);
        }
        #loading {
            text-align: center;
            padding: 20px;
        }
        .loading-details {
            font-size: 14px;
            opacity: 0.85;
            margin-top: 8px;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .loading-progress {
            width: 100%;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 12px 0;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .error-message {
            background: #5c2626;
            border: 1px solid #8b3a3a;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            display: none;
        }
        .error-message.visible {
            display: block;
        }
        .retry-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
        }
        .retry-btn:hover {
            background: #1a9ae8;
        }
        .why-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--bg-secondary, #192734);
            color: var(--accent-color, #2cafff);
            border: 1px solid var(--accent-color, #2cafff);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .why-btn:hover {
            opacity: 1;
        }
        .recommendation-reason {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 4px 0 8px 0;
            padding: 6px 10px;
            background: var(--bg-secondary, #192734);
            border-radius: 8px;
            border-left: 3px solid var(--accent-color, #2cafff);
        }
        .category-chip {
            font-size: 11px;
            color: var(--text-primary);
            background: var(--bg-primary, #15202B);
            border: 1px solid var(--accent-color, #2cafff);
            border-radius: 12px;
            padding: 3px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .category-chip:hover {
            background: var(--accent-color, #2cafff);
            color: #fff;
        }
        .category-chip.blocked {
            background: #dc2626;
            border-color: #dc2626;
            color: #fff;
        }
        .category-chip.reduced {
            background: #f59e0b;
            border-color: #f59e0b;
            color: #000;
        }
        .category-chip.boosted {
            background: #22c55e;
            border-color: #22c55e;
            color: #fff;
        }
        /* Category action dropdown */
        .category-chip-wrapper {
            position: relative;
            display: inline-block;
        }
        .category-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 4px;
            z-index: 100;
            display: none;
            flex-direction: column;
            gap: 2px;
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .category-chip-wrapper:hover .category-dropdown,
        .category-chip:focus + .category-dropdown,
        .category-dropdown:hover {
            display: flex;
        }
        .category-dropdown button {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            text-align: left;
            white-space: nowrap;
        }
        .category-dropdown button:hover {
            background: var(--bg-primary);
        }
        .category-dropdown button.active {
            background: var(--accent-color);
            color: #fff;
        }
        /* Mood mode buttons */
        .mood-section {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .mood-section h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .mood-buttons {
            display: flex;
            gap: 6px;
        }
        .mood-btn {
            flex: 1;
            padding: 8px 4px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        .mood-btn:hover {
            border-color: var(--accent-color);
        }
        .mood-btn.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: #fff;
        }
        .mood-btn .mood-icon {
            display: block;
            font-size: 16px;
            margin-bottom: 2px;
        }
        /* Presets section with h4 title */
        .presets-section {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .presets-section h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        /* Color-coded preset buttons by type */
        .preset-btn[data-type="boost"].active {
            background: #22c55e;
            border-color: #22c55e;
        }
        .preset-btn[data-type="block"].active {
            background: #dc2626;
            border-color: #dc2626;
        }
        #themeToggle {
            position: fixed;
            top: calc(16px + env(safe-area-inset-top, 0px));
            right: calc(16px + env(safe-area-inset-right, 0px));
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }
        .session-stats {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom, 0px));
            left: calc(16px + env(safe-area-inset-left, 0px));
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #historyToggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        #historyToggle:hover { opacity: 1; }
        .keyboard-hint {
            position: fixed;
            bottom: calc(45px + env(safe-area-inset-bottom, 0px));
            left: calc(16px + env(safe-area-inset-left, 0px));
            background: rgba(44, 175, 255, 0.9);
            color: #fff;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 11px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: hintFadeIn 0.3s ease-out;
        }
        .keyboard-hint kbd {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }
        .keyboard-hint button {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            padding: 0 0 0 4px;
            opacity: 0.7;
            line-height: 1;
        }
        .keyboard-hint button:hover { opacity: 1; }
        .keyboard-hint.fade-out {
            animation: hintFadeOut 0.5s ease-out forwards;
        }
        @keyframes hintFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes hintFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .history-panel {
            position: fixed;
            bottom: calc(120px + env(safe-area-inset-bottom, 0px));
            left: calc(16px + env(safe-area-inset-left, 0px));
            width: 280px;
            max-height: 300px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            z-index: 101;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
        }
        .history-header button {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            padding: 0 4px;
        }
        .history-list {
            max-height: 240px;
            overflow-y: auto;
        }
        .history-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s;
        }
        .history-item:hover { background: var(--bg-tertiary); }
        .history-item img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
        }
        .history-item .no-thumb {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        .history-item-title {
            flex: 1;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        @media (max-width: 600px) {
            .session-stats { display: none; }
        }
        .data-freshness {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 4px 0;
        }
        .surprise-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font: inherit;
            cursor: pointer;
            margin: 8px 0;
        }
        .surprise-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        /* === Feature 2: Refresh button & pull-to-refresh === */
        .floating-btn {
            position: fixed;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #2cafff;
            border: none;
            cursor: pointer;
            z-index: 250;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s, opacity 0.2s;
        }
        @media (max-width: 600px) {
            .floating-btn {
                width: 56px;
                height: 56px;
            }
            #refreshBtn {
                bottom: calc(20px + env(safe-area-inset-bottom, 0px)) !important;
            }
            #exploreBtn {
                bottom: calc(86px + env(safe-area-inset-bottom, 0px)) !important;
            }
        }
        .floating-btn:hover {
            transform: scale(1.1);
        }
        /* Tooltip styles for buttons */
        [data-tooltip] {
            position: relative;
        }
        [data-tooltip]::before {
            content: attr(data-tooltip);
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 10px;
            padding: 6px 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        [data-tooltip]:hover::before {
            opacity: 1;
        }
        /* Inline tooltips (for session stats bar) */
        .inline-tooltip[data-tooltip]::before {
            right: auto;
            left: 50%;
            top: auto;
            bottom: 100%;
            transform: translateX(-50%);
            margin-right: 0;
            margin-bottom: 8px;
        }
        /* Left-side buttons need tooltip on right */
        .tooltip-right[data-tooltip]::before {
            right: auto;
            left: 100%;
            margin-right: 0;
            margin-left: 10px;
        }
        .floating-btn:active {
            transform: scale(0.9);
        }
        #refreshBtn {
            right: calc(24px + env(safe-area-inset-right, 0px));
            bottom: calc(24px + env(safe-area-inset-bottom, 0px));
        }
        #exploreBtn {
            right: calc(24px + env(safe-area-inset-right, 0px));
            bottom: calc(84px + env(safe-area-inset-bottom, 0px));
        }
        #exploreBtn::after {
            content: "üé≤";
            font-size: 20px;
        }
        #exploreBtn.active {
            background: #22c55e;
            box-shadow: 0 0 20px #22c55e, 0 0 40px #22c55e55;
            animation: explorePulse 1.5s ease-in-out infinite;
        }
        @keyframes explorePulse {
            0%, 100% { box-shadow: 0 0 20px #22c55e, 0 0 40px #22c55e55; }
            50% { box-shadow: 0 0 30px #22c55e, 0 0 60px #22c55e88; }
        }
        .toast {
            position: fixed;
            bottom: calc(140px + env(safe-area-inset-bottom, 0px));
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: toastSlide 2s ease-out forwards;
            pointer-events: none;
        }
        @keyframes toastSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        #exploreBtn.active::after {
            content: "üé≤";
            filter: drop-shadow(0 0 6px white);
        }
        #refreshBtn::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M17.65 6.35A7.96 7.96 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" fill="white"/></svg>');
        }
        .pull-to-refresh-indicator {
            text-align: center;
            padding: 12px;
            color: #8899AA;
            font-size: 14px;
            transition: opacity 0.3s;
            overflow: hidden;
            height: 0;
        }
        .pull-to-refresh-indicator.active {
            height: auto;
        }
        .pull-to-refresh-indicator .spinner {
            display: inline-block;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* === Feature 1: More/Less feedback buttons === */
        /* Icons are now added via CSS ::before with emoji */
        .post .feedback-btn {
            position: relative;
            font-size: 13px;
            color: var(--text-secondary);
            background: transparent;
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .post .feedback-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }
        .post .feedback-btn:disabled {
            opacity: 0.5;
            cursor: default;
        }
        .post .more-btn::before {
            content: 'üëç ';
        }
        .post .less-btn::before {
            content: 'üëé ';
        }
        .post .feedback-btn .got-it {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: var(--accent-color, #2cafff);
            white-space: nowrap;
            pointer-events: none;
            animation: gotItFade 1s ease-out forwards;
        }
        @keyframes gotItFade {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            70% { opacity: 1; transform: translateX(-50%) translateY(-4px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
        }
        @keyframes postSlideAway {
            0% { opacity: 1; transform: translateX(0); max-height: 1000px; }
            50% { opacity: 0; transform: translateX(-100px); max-height: 1000px; }
            100% { opacity: 0; transform: translateX(-100px); max-height: 0; padding: 0; margin: 0; border: none; }
        }
        .post.sliding-away {
            animation: postSlideAway 0.4s ease-out forwards;
            overflow: hidden;
        }
        .post .button-spacer {
            flex: 1;
        }

        /* === Feature 3: Sidebar category controls === */
        .stats-section-title {
            font-weight: bold;
            color: var(--text-secondary, #8899AA);
            margin: 8px 0 4px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .cat-row {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .cat-row .cat-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        .cat-row .cat-score {
            color: var(--text-secondary, #8899AA);
            min-width: 40px;
            text-align: right;
            margin-right: 4px;
        }
        .cat-row .cat-ctrl {
            width: 20px;
            height: 20px;
            border: 1px solid var(--border-color, #38444D);
            border-radius: 4px;
            background: transparent;
            color: var(--text-secondary, #8899AA);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            flex-shrink: 0;
        }
        .cat-row .cat-ctrl:hover {
            background: var(--bg-secondary, #1C2732);
            color: var(--text-primary, #FFF);
            border-color: var(--accent-color, #2cafff);
        }
        .hidden-section {
            margin-top: 8px;
            border-top: 1px solid var(--border-color, #38444D);
            padding-top: 4px;
        }
        .hidden-toggle {
            cursor: pointer;
            color: var(--text-secondary, #8899AA);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: none;
            border: none;
            padding: 4px 0;
            font-family: monospace;
            width: 100%;
            text-align: left;
        }
        .hidden-toggle:hover {
            color: var(--text-primary, #FFF);
        }
        .hidden-list {
            display: none;
        }
        .hidden-list.expanded {
            display: block;
        }
        .hidden-row {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .hidden-row .cat-name {
            flex: 1;
            color: var(--text-secondary, #8899AA);
            text-decoration: line-through;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        .unhide-btn {
            font-size: 10px;
            color: var(--accent-color, #2cafff);
            background: none;
            border: 1px solid var(--border-color, #38444D);
            border-radius: 4px;
            cursor: pointer;
            padding: 2px 6px;
            font-family: monospace;
            flex-shrink: 0;
        }
        .unhide-btn:hover {
            background: var(--bg-secondary, #1C2732);
            border-color: var(--accent-color, #2cafff);
        }

        /* === Algorithm aggressiveness slider === */
        .algo-slider-section {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color, #38444D);
        }
        .algo-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: var(--text-secondary, #8899AA);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .algo-slider-value {
            font-family: monospace;
            color: var(--accent-color, #2cafff);
        }
        .algo-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-secondary, #1C2732);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        .algo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color, #2cafff);
            cursor: pointer;
            border: 2px solid var(--bg-primary, #15202B);
        }
        .algo-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color, #2cafff);
            cursor: pointer;
            border: 2px solid var(--bg-primary, #15202B);
        }
        .algo-slider-scale {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: var(--text-secondary, #8899AA);
            margin-top: 2px;
            opacity: 0.7;
        }
        .algo-slider-hint {
            font-size: 10px;
            color: var(--text-secondary, #8899AA);
            margin-top: 4px;
            margin-top: 4px;
            opacity: 0.7;
        }
        
        /* === Filter Presets === */
        .filter-presets-section {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color, #38444D);
        }
        .section-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary, #8899AA);
            margin-bottom: 8px;
        }
        .presets-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .preset-btn {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color, #38444D);
            background: var(--bg-primary, #15202B);
            color: var(--text-secondary, #8899AA);
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        .preset-btn:hover {
            border-color: var(--accent-color, #2cafff);
            color: var(--text-primary);
        }
        .preset-btn.active {
            background: var(--accent-color, #2cafff);
            border-color: var(--accent-color, #2cafff);
            color: #fff;
        }

        /* === Feature 4: Mobile sidebar drawer === */
        #statsToggleBtn {
            position: fixed;
            left: 24px;
            bottom: 24px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent-color, #2cafff);
            border: none;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        #statsToggleBtn:hover {
            transform: scale(1.1);
        }
        #statsToggleBtn:active {
            transform: scale(0.9);
        }
        #statsToggleBtn::after {
            content: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M5 9.2h3V19H5V9.2zM10.6 5h2.8v14h-2.8V5zm5.6 8H19v6h-2.8v-6z" fill="white"/></svg>');
        }
        @media (max-width: 600px) {
            .stats {
                max-width: 80vw;
            }
        }
        .stats-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 199;
        }
        .stats-backdrop.visible {
            display: block;
        }
        .stats-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: var(--text-secondary, #8899AA);
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            display: block;
            z-index: 201;
        }
        .stats-close:hover {
            color: var(--text-primary, #FFF);
        }

        /* === Auth UI === */
        #authSection {
            margin: 12px 0;
            border: 1px solid #38444D;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .auth-tabs {
            display: flex;
            border-bottom: 1px solid #38444D;
        }
        .auth-tab {
            flex: 1;
            padding: 8px 12px;
            background: transparent;
            color: #8899AA;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font: inherit;
            font-size: 14px;
            transition: color 0.2s, border-color 0.2s;
        }
        .auth-tab:hover {
            color: #FFF;
        }
        .auth-tab.active {
            color: #2cafff;
            border-bottom-color: #2cafff;
        }
        .auth-tab-content {
            display: none;
            padding: 12px;
        }
        .auth-tab-content.active {
            display: block;
        }
        .auth-tab-content input[type="text"],
        .auth-tab-content input[type="password"] {
            width: 100%;
            box-sizing: border-box;
            border-radius: 32px;
            padding: 10px 14px;
            background: #000;
            color: #FFF;
            border: 1px solid #38444D;
            font: inherit;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .auth-tab-content input[type="text"]:focus,
        .auth-tab-content input[type="password"]:focus {
            outline: none;
            border-color: #2cafff;
        }
        .auth-submit-btn {
            width: 100%;
            border-radius: 32px;
            padding: 10px;
            background: #2cafff;
            color: #FFF;
            border: none;
            font: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .auth-submit-btn:hover {
            opacity: 0.9;
        }
        .auth-submit-btn:disabled {
            background: #557;
            cursor: not-allowed;
        }
        .auth-error {
            color: #ff6b6b;
            font-size: 13px;
            margin-top: 4px;
            min-height: 0;
        }
        .auth-guest-msg {
            color: #8899AA;
            font-size: 13px;
            margin: 4px 0;
        }
        .auth-welcome {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            font-size: 14px;
        }
        .auth-welcome a {
            font-size: 13px;
            cursor: pointer;
        }
        #logoutBtn {
            position: fixed;
            top: 12px;
            right: 12px;
            background: transparent;
            border: 1px solid #38444D;
            color: #8899AA;
            padding: 6px 14px;
            border-radius: 20px;
            font: inherit;
            font-size: 12px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
        #logoutBtn:hover {
            color: #FFF;
            border-color: #2cafff;
        }
        #deleteAccountBtn {
            position: fixed;
            top: 12px;
            right: 100px;
            background: transparent;
            border: 1px solid #38444D;
            color: #664444;
            padding: 6px 14px;
            border-radius: 20px;
            font: inherit;
            font-size: 11px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
        #deleteAccountBtn:hover {
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        /* === Offline Indicator === */
        #offlineIndicator {
            position: fixed;
            top: calc(16px + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translateX(-50%);
            background: #f59e0b;
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #offlineIndicator.visible {
            display: flex;
        }
        #offlineIndicator::before {
            content: 'üì°';
        }

        /* === Update Toast === */
        #updateToast {
            position: fixed;
            bottom: calc(200px + env(safe-area-inset-bottom, 0px));
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-color, #2cafff);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 280px;
            text-align: center;
        }
        #updateToast.visible {
            display: flex;
        }
        #updateToast button {
            background: #fff;
            color: var(--accent-color, #2cafff);
            border: none;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }
        #updateToast button:hover {
            opacity: 0.9;
        }
        #updateToast .dismiss {
            background: transparent;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <button id="themeToggle" class="inline-tooltip" aria-label="Toggle dark/light mode" data-tooltip="Theme">&#127769;</button>
    <p id="loading">Loading...</p>
    <div class="posts" data-testid="posts" role="feed" aria-label="Wikipedia article feed"></div>
    <div id="sessionStats" class="session-stats">
        <span id="viewCount">0</span> viewed ¬∑ <span id="likeCount">0</span> liked
        <button id="historyToggle" class="inline-tooltip" aria-label="Show reading history" data-tooltip="History (H)" style="display:none">üìú</button>
    </div>
    <div id="keyboardHint" class="keyboard-hint" style="display:none">
        Press <kbd>?</kbd> for keyboard shortcuts
        <button id="keyboardHintDismiss" aria-label="Dismiss hint">√ó</button>
    </div>
    <div id="historyPanel" class="history-panel" style="display:none">
        <div class="history-header">
            <span>üìú Reading History</span>
            <button id="historyClose" aria-label="Close history">√ó</button>
        </div>
        <div id="historyList" class="history-list"></div>
    </div>
    <aside class="stats" data-testid="stats" aria-live="polite" aria-label="Category engagement scores">
        <button class="stats-close" aria-label="Close sidebar">&times;</button>
    </aside>
    <div class="stats-backdrop" id="statsBackdrop"></div>
    <button id="statsToggleBtn" class="tooltip-right" aria-label="Open category stats" data-tooltip="Stats (S)"></button>
    <button class="floating-btn" id="refreshBtn" aria-label="Refresh feed" data-tooltip="Refresh (R)" style="display:none"></button>
    <button class="floating-btn" id="exploreBtn" aria-label="Toggle explore mode" data-tooltip="Explore (E)" style="display:none"></button>
    <div id="startScreen" popover="manual">
        <div>
            <h1>Xikipedia</h1>
            <h2 style="font-size: 100%;opacity:0.85;font-style:italic">
                by <a href="https://lyra.horse">rebane2001</a>
            </h2>
        </div>
        <p>
            <strong>Xikipedia</strong> is a pseudo social media feed that algorithmically shows you content from 
            <a href="https://simple.wikipedia.org/">Simple Wikipedia</a> (click any article to read the full version on <a href="https://en.wikipedia.org/">Wikipedia</a>). It is made as a demonstration of how 
            even a basic non-ML algorithm with no data from other users can quickly learn what you engage with 
            to suggest you more similar content. No data is collected or shared here, the algorithm runs locally 
            and the data disappears once you refresh or close the tab.
        </p>
        <p>
            Original source on <a href="https://github.com/rebane2001/xikipedia">GitHub</a>.
            Recreation hosted on Cloudflare Workers.
        </p>
        <div id="authSection">
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="guest">Guest</button>
                <button class="auth-tab" data-tab="login">Login</button>
                <button class="auth-tab" data-tab="register">Register</button>
            </div>
            <div class="auth-tab-content active" data-tab-content="guest">
                <p class="auth-guest-msg">Browse without an account. Your preferences won't be saved.</p>
            </div>
            <div class="auth-tab-content" data-tab-content="login">
                <input type="text" id="loginUsername" placeholder="Username" autocomplete="username">
                <input type="password" id="loginPassword" placeholder="Password" autocomplete="current-password">
                <button class="auth-submit-btn" id="loginBtn">Log in</button>
                <div class="auth-error" id="loginError"></div>
            </div>
            <div class="auth-tab-content" data-tab-content="register">
                <input type="text" id="registerUsername" placeholder="Username" autocomplete="username">
                <input type="password" id="registerPassword" placeholder="Password" autocomplete="new-password">
                <input type="password" id="registerConfirm" placeholder="Confirm password" autocomplete="new-password">
                <button class="auth-submit-btn" id="registerBtn">Create account</button>
                <div class="auth-error" id="registerError"></div>
            </div>
        </div>
        <div id="categoryPickerSection">
        <p style="font-weight: 600;margin:0">Pick some categories to get started (optional)</p>
        <div id="categoryPickList"></div>
        <button id="surpriseMe" class="surprise-btn">üé≤ Surprise me!</button>
        <p style="font-weight: 600;margin:0">Or add your own</p>
        <div id="categorySearch" style="display:flex;flex-direction:column">
            <input placeholder="Estonia..." disabled data-testid="category-search-input" aria-label="Search for categories">
            <select size="5" data-testid="category-search-select" aria-label="Category search results"></select>
        </div>
        </div>
        <p style="margin-top:auto">
            Since the content and images shown is from random Wikipedia articles, you will likely see
            NSFW content. Please only continue if you're an adult.
        </p>
        <p class="data-freshness">Data last updated: <span id="lastUpdated">February 2026</span></p>
        <div class="loading-progress" id="loadingProgress" style="display:none">
            <div class="loading-progress-bar" id="loadingProgressBar"></div>
        </div>
        <div class="loading-details" id="loadingDetails"></div>
        <div class="error-message" id="errorMessage">
            <strong>Failed to load data</strong>
            <p id="errorText">Network error occurred.</p>
            <button class="retry-btn" id="retryBtn">Try again</button>
        </div>
        <button id="startBtn" disabled data-testid="start-button" aria-label="Start browsing Xikipedia (adult content warning)">I'm an adult, continue</button>
    </div>
    <button id="logoutBtn">Log out</button>
    <button id="deleteAccountBtn">Delete account</button>
<script>
    // ============================================
    // Xikipedia - Wikipedia as a Social Media Feed
    // Original by rebane2001 (https://lyra.horse)
    // Recreation for Cloudflare Workers deployment
    // ============================================

    // Theme toggle functionality
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.onclick = () => {
        document.documentElement.classList.toggle('light-mode');
        themeToggle.textContent = document.documentElement.classList.contains('light-mode') ? '\u2600\uFE0F' : '\uD83C\uDF19';
        localStorage.setItem('theme', document.documentElement.classList.contains('light-mode') ? 'light' : 'dark');
    };
    // Load saved theme
    if (localStorage.getItem('theme') === 'light') {
        document.documentElement.classList.add('light-mode');
        themeToggle.textContent = '\u2600\uFE0F';
    }

    const DATA_LAST_UPDATED = "February 2026";
    const pagesArr = [];
    let noPageMaps = {};
    const recursiveCache = new Map();

    // Session stats tracking
    let articlesViewed = 0;
    let articlesLiked = 0;
    const viewedHistory = []; // Track viewed articles for history feature
    let currentStreak = 0;
    let maxStreak = 0;

    const categoryScores = {
        "given names": -1000,
        "surnames": -1000,
    };
    const hiddenCategories = new Set();
    const reducedCategories = new Set();  // 75% less likely to show
    const boostedCategories = new Set();  // 3x more likely to show
    
    // Mood modes: normal, light (hide dark topics), deep (STEM/academic focus)
    let moodMode = 'normal';
    
    // Filter presets - pre-built category groups
    const filterPresets = {
        noDark: {
            name: "üö´ No dark topics",
            type: "block",
            categories: ["war", "wars", "death", "deaths", "murder", "murders", "crime", "crimes", 
                        "disaster", "disasters", "disease", "diseases", "terrorism", "genocide",
                        "violence", "accidents", "famine", "poverty", "torture", "execution",
                        "suicide", "assassination", "massacre", "bombing", "shooting"]
        },
        noPolitics: {
            name: "üèõÔ∏è No politics",
            type: "block",
            categories: ["politicians", "politics", "political parties", "elections", "governments",
                        "presidents", "prime ministers", "senators", "congress", "parliament",
                        "democrats", "republicans", "conservatives", "liberals", "political",
                        "diplomacy", "treaties", "legislation"]
        },
        stemBoost: {
            name: "üî¨ STEM boost",
            type: "boost",
            categories: ["science", "technology", "mathematics", "engineering", "physics", 
                        "chemistry", "biology", "computer science", "astronomy", "medicine",
                        "geology", "ecology", "genetics", "neuroscience", "algorithms"]
        },
        cultureBoost: {
            name: "üé® Culture boost",
            type: "boost",
            categories: ["art", "music", "film", "literature", "theatre", "dance", 
                        "painting", "sculpture", "poetry", "novels", "architecture",
                        "photography", "fashion", "design", "museums", "galleries"]
        },
        historyBoost: {
            name: "üìú History boost",
            type: "boost",
            categories: ["history", "ancient", "medieval", "archaeology", "civilizations",
                        "empires", "dynasties", "historical", "centuries", "antiquity"]
        },
        natureBoost: {
            name: "üåø Nature boost",
            type: "boost",
            categories: ["nature", "animals", "plants", "wildlife", "ecology", "environment",
                        "forests", "oceans", "mountains", "conservation", "species"]
        }
    };
    
    // Mood mode presets - define what each mood does
    const moodPresets = {
        light: {
            block: ["war", "wars", "death", "deaths", "murder", "murders", "crime", "crimes",
                   "disaster", "disasters", "disease", "diseases", "terrorism", "genocide",
                   "violence", "accidents", "famine", "poverty", "torture", "execution",
                   "suicide", "assassination", "massacre", "bombing", "shooting"],
            boost: ["art", "music", "nature", "animals", "food", "sports", "games", "comedy",
                   "entertainment", "travel", "festivals", "holidays", "culture"]
        },
        deep: {
            block: ["celebrities", "entertainment", "sports", "athletes", "actors", "musicians",
                   "reality television", "social media", "influencers", "pop culture"],
            boost: ["science", "philosophy", "mathematics", "history", "literature", "physics",
                   "chemistry", "biology", "psychology", "sociology", "anthropology", "economics",
                   "linguistics", "archaeology", "astronomy", "medicine", "engineering"]
        }
    };
    
    // Active filter presets
    const activePresets = new Set();
    
    // Save all category filters to localStorage
    function saveCategoryFilters() {
        localStorage.setItem('xiki_blocked_categories', JSON.stringify(Array.from(hiddenCategories)));
        localStorage.setItem('xiki_reduced_categories', JSON.stringify(Array.from(reducedCategories)));
        localStorage.setItem('xiki_boosted_categories', JSON.stringify(Array.from(boostedCategories)));
        localStorage.setItem('xiki_active_presets', JSON.stringify(Array.from(activePresets)));
        localStorage.setItem('xiki_mood_mode', moodMode);
    }
    
    // Load all category filters from localStorage
    function loadCategoryFilters() {
        try {
            const blocked = localStorage.getItem('xiki_blocked_categories');
            if (blocked) JSON.parse(blocked).forEach(cat => hiddenCategories.add(cat));
            
            const reduced = localStorage.getItem('xiki_reduced_categories');
            if (reduced) JSON.parse(reduced).forEach(cat => reducedCategories.add(cat));
            
            const boosted = localStorage.getItem('xiki_boosted_categories');
            if (boosted) JSON.parse(boosted).forEach(cat => boostedCategories.add(cat));
            
            const savedPresets = localStorage.getItem('xiki_active_presets');
            if (savedPresets) JSON.parse(savedPresets).forEach(p => activePresets.add(p));
            
            const savedMood = localStorage.getItem('xiki_mood_mode');
            if (savedMood) moodMode = savedMood;
        } catch (e) {
            console.warn('Failed to load category filters:', e);
        }
    }
    
    // Legacy alias for backward compatibility
    function saveBlockedCategories() { saveCategoryFilters(); }
    function loadBlockedCategories() { loadCategoryFilters(); }
    
    // Apply a filter preset (supports both block and boost types)
    function toggleFilterPreset(presetKey) {
        const preset = filterPresets[presetKey];
        if (!preset) return;
        
        const targetSet = preset.type === 'boost' ? boostedCategories : hiddenCategories;
        
        if (activePresets.has(presetKey)) {
            // Disable preset - remove categories
            activePresets.delete(presetKey);
            preset.categories.forEach(cat => targetSet.delete(cat));
            showToast(`Disabled: ${preset.name}`);
        } else {
            // Enable preset - add categories
            activePresets.add(presetKey);
            preset.categories.forEach(cat => targetSet.add(cat));
            showToast(`Enabled: ${preset.name}`);
        }
        saveCategoryFilters();
        updatePresetButtons();
        scheduleEngagementUpdate();
    }
    
    // Set mood mode (normal, light, deep)
    function setMoodMode(mode) {
        if (mode === moodMode) return;
        
        // Clear previous mood's effects (only for non-normal modes)
        if (moodMode !== 'normal' && moodPresets[moodMode]) {
            const prev = moodPresets[moodMode];
            prev.block?.forEach(cat => hiddenCategories.delete(cat));
            prev.boost?.forEach(cat => boostedCategories.delete(cat));
        }
        
        moodMode = mode;
        
        // Apply new mood's effects
        if (mode !== 'normal' && moodPresets[mode]) {
            const preset = moodPresets[mode];
            preset.block?.forEach(cat => hiddenCategories.add(cat));
            preset.boost?.forEach(cat => boostedCategories.add(cat));
        }
        
        saveCategoryFilters();
        updateMoodButtons();
        scheduleEngagementUpdate();
        
        const moodNames = { normal: '‚öñÔ∏è Normal', light: '‚òÄÔ∏è Light', deep: 'üß† Deep Dive' };
        showToast(`Mood: ${moodNames[mode]}`);
    }
    
    // Update mood button UI state
    function updateMoodButtons() {
        document.querySelectorAll('.mood-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mood === moodMode);
        });
    }
    
    // Update preset button UI state
    function updatePresetButtons() {
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.classList.toggle('active', activePresets.has(btn.dataset.preset));
        });
    }
    
    // Set category filter action (block, reduce, boost, clear)
    function setCategoryFilter(category, action) {
        // Clear from all sets first
        hiddenCategories.delete(category);
        reducedCategories.delete(category);
        boostedCategories.delete(category);
        
        // Apply new action
        switch (action) {
            case 'block':
                hiddenCategories.add(category);
                showToast(`üö´ Blocked: ${convertCat(category)}`);
                break;
            case 'reduce':
                reducedCategories.add(category);
                showToast(`‚¨áÔ∏è Reduced: ${convertCat(category)}`);
                break;
            case 'boost':
                boostedCategories.add(category);
                showToast(`‚¨ÜÔ∏è Boosted: ${convertCat(category)}`);
                break;
            case 'clear':
                showToast(`‚úì Cleared: ${convertCat(category)}`);
                break;
        }
        
        saveCategoryFilters();
        scheduleEngagementUpdate();
    }
    
    // Get current filter status for a category
    function getCategoryFilterStatus(category) {
        if (hiddenCategories.has(category)) return 'blocked';
        if (reducedCategories.has(category)) return 'reduced';
        if (boostedCategories.has(category)) return 'boosted';
        return 'normal';
    }
    
    const defaultCategories = [
        "nature", "science", "animals", "anthropology", "places",
        "sociology", "art", "mathematics", "games", "technology",
        "music", "human sexuality"
    ];
    let postsWithoutLike = 0;
    let exploreMode = false;
    let algorithmAggressiveness = 50; // 0-100: 0=random, 50=balanced, 100=strict scoring
    const seenPostIds = new Set(); // Hard block: never show same post twice
    const DATA_SIZE = 225690064;

    // === Randomness features ===
    let postsSinceRandom = 0;           // Serendipity: counter for random injection
    let lastTopCategory = null;         // Variety: track dominant category
    let consecutiveSameCategory = 0;    // Variety: count streak in same category
    const exploredCategories = new Set(); // Roulette: categories we've engaged with

    // === Time-based decay ===
    const categoryLastEngaged = {};     // Track when each category was last positively engaged
    const sessionStartTime = Date.now();
    
    // Calculate decay factor based on age (0.5 per hour, minimum 0.1)
    function getDecayFactor(category) {
        const lastEngaged = categoryLastEngaged[category];
        if (!lastEngaged) return 0.5; // Never engaged = 50% weight
        const ageMs = Date.now() - lastEngaged;
        const ageHours = ageMs / (1000 * 60 * 60);
        // Decay: starts at 1.0, halves every 2 hours, floor at 0.1
        // Faster decay: halves every hour (was every 2 hours)
        return Math.max(0.1, Math.pow(0.5, ageHours));
    }

    // Load persisted seen posts from localStorage
    function loadSeenPosts() {
        try {
            const saved = localStorage.getItem('xiki_seen_posts');
            if (saved) {
                const ids = JSON.parse(saved);
                if (Array.isArray(ids)) {
                    ids.forEach(id => seenPostIds.add(id));
                }
            }
        } catch (e) {
            console.warn('Failed to load seen posts:', e);
        }
    }

    // Save seen posts to localStorage (debounced, keeps last 5000)
    let saveSeenTimeout = null;
    function saveSeenPosts() {
        if (saveSeenTimeout) clearTimeout(saveSeenTimeout);
        saveSeenTimeout = setTimeout(() => {
            try {
                // Keep only last 5000 to avoid localStorage bloat
                const ids = [...seenPostIds].slice(-5000);
                localStorage.setItem('xiki_seen_posts', JSON.stringify(ids));
            } catch (e) {
                console.warn('Failed to save seen posts:', e);
            }
        }, 1000);
    }

    // ============================================
    // Auth state management
    // ============================================

    function isLoggedIn() {
        return !!localStorage.getItem('xiki_token');
    }

    function currentUser() {
        return localStorage.getItem('xiki_username') || null;
    }

    function getAuthHeaders() {
        const token = localStorage.getItem('xiki_token');
        if (token) return { 'Authorization': 'Bearer ' + token };
        return {};
    }

    function logout() {
        localStorage.removeItem('xiki_token');
        localStorage.removeItem('xiki_username');
        window.location.reload();
    }

    async function deleteAccount() {
        const password = prompt('Enter your password to confirm account deletion:');
        if (!password) return;
        if (!confirm('Are you sure? This cannot be undone.')) return;
        try {
            const resp = await fetch('/api/account', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    ...getAuthHeaders()
                },
                body: JSON.stringify({ password })
            });
            if (!resp.ok) {
                const data = await resp.json().catch(() => ({}));
                alert(data.error || 'Failed to delete account. Please try again.');
                return;
            }
        } catch (e) {
            console.error('Delete account failed:', e);
            alert('Failed to delete account. Please try again.');
            return;
        }
        localStorage.removeItem('xiki_token');
        localStorage.removeItem('xiki_username');
        window.location.reload();
    }

    // Debounced preference saving
    let saveTimeout = null;
    function savePreferences() {
        if (!isLoggedIn()) return;
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            const body = {
                categoryScores: categoryScores,
                hiddenCategories: Array.from(hiddenCategories),
                algorithmAggressiveness: algorithmAggressiveness
            };
            fetch('/api/preferences', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    ...getAuthHeaders()
                },
                body: JSON.stringify(body)
            }).catch(e => console.error('Failed to save preferences:', e));
        }, 5000);
    }

    // Double-tap detection state
    let lastTapTime = 0;
    let lastTapTarget = null;
    let singleTapTimer = null;

    // DOM Elements
    const startBtn = document.getElementById("startBtn");
    const startScreen = document.getElementById("startScreen");
    const categoryPickList = document.getElementById("categoryPickList");
    const categorySearch = document.getElementById("categorySearch");
    const categorySearchInput = categorySearch.querySelector("input");
    const categorySearchSelect = categorySearch.querySelector("select");

    // Category search functionality
    categorySearchInput.oninput = () => {
        const searchText = categorySearchInput.value;
        if (!searchText.length) {
            categorySearchSelect.innerText = "";
            return;
        }
        const searchTarget = [
            ...pagesArr.map(e => e.title.toLowerCase()), 
            ...Object.values(noPageMaps).map(e => e.toLowerCase())
        ];
        let results = searchTarget
            .filter(e => e.startsWith(searchText.toLowerCase()))
            .slice(0, 100);
        if (results.length < 100) {
            results = [
                ...results, 
                ...searchTarget
                    .filter(e => e.includes(searchText.toLowerCase()) && !results.includes(e))
                    .slice(0, 100 - results.length)
            ];
        }
        if (results.length === 100) {
            results.push("...");
        }
        categorySearchSelect.innerText = "";
        results.forEach(e => {
            const option = document.createElement("option");
            option.innerText = `${e.slice(0, 1).toUpperCase()}${e.slice(1).toLowerCase()}`;
            option.value = e;
            categorySearchSelect.appendChild(option);
        });
    };

    categorySearchSelect.oninput = () => {
        if (!categorySearchSelect.value || categorySearchSelect.value === "...") return;
        addPickableCategory(categorySearchSelect.value, true);
    };

    // Surprise me button handler
    document.getElementById('surpriseMe').onclick = () => {
        // Uncheck all current selections
        document.querySelectorAll('.categoryPicker input:checked').forEach(cb => cb.checked = false);

        // Pick 3-5 random categories from defaultCategories
        const shuffled = [...defaultCategories].sort(() => Math.random() - 0.5);
        const count = 3 + Math.floor(Math.random() * 3); // 3-5 categories
        const selected = shuffled.slice(0, count);

        // Check those categories
        selected.forEach(cat => {
            const checkbox = document.querySelector(`.categoryPicker input[data-category="${cat}"]`);
            if (checkbox) checkbox.checked = true;
        });
    };

    // ============================================
    // Auth UI: Tab switching and form submission
    // ============================================

    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.onclick = () => {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-tab-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.querySelector(`[data-tab-content="${tab.dataset.tab}"]`).classList.add('active');
        };
    });

    async function handleLogin() {
        const username = document.getElementById('loginUsername').value.trim();
        const password = document.getElementById('loginPassword').value;
        const errorEl = document.getElementById('loginError');
        const btn = document.getElementById('loginBtn');

        if (!username || !password) {
            errorEl.textContent = 'Please enter username and password.';
            return;
        }

        errorEl.textContent = '';
        btn.disabled = true;
        btn.textContent = 'Logging in...';

        try {
            const resp = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            const data = await resp.json();
            if (!resp.ok) {
                errorEl.textContent = data.error || 'Login failed.';
                btn.disabled = false;
                btn.textContent = 'Log in';
                return;
            }
            localStorage.setItem('xiki_token', data.token);
            localStorage.setItem('xiki_username', data.username);
            window.location.reload();
        } catch (e) {
            errorEl.textContent = 'Network error. Please try again.';
            btn.disabled = false;
            btn.textContent = 'Log in';
        }
    }

    async function handleRegister() {
        const username = document.getElementById('registerUsername').value.trim();
        const password = document.getElementById('registerPassword').value;
        const confirmPw = document.getElementById('registerConfirm').value;
        const errorEl = document.getElementById('registerError');
        const btn = document.getElementById('registerBtn');

        if (!username || !password) {
            errorEl.textContent = 'Please enter username and password.';
            return;
        }
        if (password !== confirmPw) {
            errorEl.textContent = 'Passwords do not match.';
            return;
        }

        errorEl.textContent = '';
        btn.disabled = true;
        btn.textContent = 'Creating account...';

        try {
            const resp = await fetch('/api/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            const data = await resp.json();
            if (!resp.ok) {
                errorEl.textContent = data.error || 'Registration failed.';
                btn.disabled = false;
                btn.textContent = 'Create account';
                return;
            }
            localStorage.setItem('xiki_token', data.token);
            localStorage.setItem('xiki_username', data.username);
            window.location.reload();
        } catch (e) {
            errorEl.textContent = 'Network error. Please try again.';
            btn.disabled = false;
            btn.textContent = 'Create account';
        }
    }

    document.getElementById('loginBtn').onclick = handleLogin;
    document.getElementById('registerBtn').onclick = handleRegister;

    // Allow Enter key to submit auth forms
    document.getElementById('loginPassword').onkeydown = (e) => {
        if (e.key === 'Enter') handleLogin();
    };
    document.getElementById('registerConfirm').onkeydown = (e) => {
        if (e.key === 'Enter') handleRegister();
    };

    // Logout and delete account buttons
    document.getElementById('logoutBtn').onclick = logout;
    document.getElementById('deleteAccountBtn').onclick = deleteAccount;

    // Recursive category expansion with memoization
    function recursiveCategories(subCategories, categories, depth) {
        const allCategories = new Set(categories);
        categories.forEach(e => {
            const cat = e?.toLowerCase?.();
            if (!cat) return;
            const subs = subCategories[cat] ?? [];
            if (!subs.length) return;
            
            let cacheValue = recursiveCache.get(cat);
            if (!cacheValue) {
                recursiveCache.set(cat, -1);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            } else if (cacheValue === -1) {
                recursiveCache.set(cat, []);
                cacheValue = recursiveCategories(subCategories, subs, depth + 1);
                recursiveCache.set(cat, cacheValue);
            }
            allCategories.add(...subs);
            allCategories.add(...cacheValue);
        });
        return new Set([...allCategories].map(e => e?.toLowerCase?.() || e));
    }

    // Convert category ID to display name
    function convertCat(cat) {
        if (cat.startsWith("p:")) {
            cat = cat.slice(2);
            return pagesArr.find(e => e.id == cat)?.title ?? noPageMaps[cat] ?? cat;
        }
        return cat;
    }

    // Update the stats sidebar
    // Debounced sidebar update to prevent DOM thrash on rapid clicks
    let engagementUpdateScheduled = false;
    function scheduleEngagementUpdate() {
        if (engagementUpdateScheduled) return;
        engagementUpdateScheduled = true;
        requestAnimationFrame(() => {
            updateEngagement();
            engagementUpdateScheduled = false;
        });
    }

    // Update the stats sidebar with interactive controls
    // Toast notification helper
    function showToast(message) {
        const existing = document.querySelector('.toast');
        if (existing) existing.remove();
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        toast.addEventListener('animationend', () => toast.remove());
    }

    function updateEngagement() {
        const statsEl = document.querySelector(".stats");
        // Preserve close button for mobile drawer
        const closeBtn = statsEl.querySelector(".stats-close");
        statsEl.innerHTML = "";
        if (closeBtn) statsEl.appendChild(closeBtn);

        // Algorithm aggressiveness slider
        const sliderSection = document.createElement("div");
        sliderSection.classList.add("algo-slider-section");

        const sliderLabel = document.createElement("div");
        sliderLabel.classList.add("algo-slider-label");
        sliderLabel.innerHTML = `<span>Personalization</span><span class="algo-slider-value">${algorithmAggressiveness}%</span>`;

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "0";
        slider.max = "100";
        slider.step = "5";
        slider.value = String(algorithmAggressiveness);
        slider.classList.add("algo-slider");
        slider.setAttribute("aria-label", "Algorithm aggressiveness");
        slider.oninput = (e) => {
            algorithmAggressiveness = parseInt(e.target.value, 10);
            sliderLabel.querySelector(".algo-slider-value").textContent = `${algorithmAggressiveness}%`;
            savePreferences();
        };

        const scaleLabels = document.createElement("div");
        scaleLabels.classList.add("algo-slider-scale");
        scaleLabels.innerHTML = `<span>Random</span><span>Personalized</span>`;

        const hint = document.createElement("div");
        hint.classList.add("algo-slider-hint");
        hint.textContent = algorithmAggressiveness === 0 ? "üé≤ Pure random" :
                          algorithmAggressiveness < 30 ? "üéØ Mostly random" :
                          algorithmAggressiveness < 70 ? "‚öñÔ∏è Balanced" :
                          algorithmAggressiveness < 100 ? "üî• Strong preferences" :
                          "üéØ Strict scoring";

        sliderSection.appendChild(sliderLabel);
        sliderSection.appendChild(slider);
        sliderSection.appendChild(scaleLabels);
        sliderSection.appendChild(hint);
        statsEl.appendChild(sliderSection);

        // Mood mode section
        const moodSection = document.createElement("div");
        moodSection.classList.add("mood-section");
        
        const moodTitle = document.createElement("h4");
        moodTitle.textContent = "Reading Mood";
        moodSection.appendChild(moodTitle);
        
        const moodButtons = document.createElement("div");
        moodButtons.classList.add("mood-buttons");
        
        const moods = [
            { id: 'light', icon: '‚òÄÔ∏è', label: 'Light' },
            { id: 'normal', icon: '‚öñÔ∏è', label: 'Normal' },
            { id: 'deep', icon: 'üß†', label: 'Deep' }
        ];
        
        moods.forEach(({ id, icon, label }) => {
            const btn = document.createElement("button");
            btn.classList.add("mood-btn");
            btn.dataset.mood = id;
            if (moodMode === id) btn.classList.add("active");
            btn.innerHTML = `<span class="mood-icon">${icon}</span>${label}`;
            btn.setAttribute("aria-label", `${label} reading mode`);
            btn.setAttribute("aria-pressed", moodMode === id);
            btn.onclick = (e) => {
                e.stopPropagation();
                setMoodMode(id);
            };
            moodButtons.appendChild(btn);
        });
        
        moodSection.appendChild(moodButtons);
        statsEl.appendChild(moodSection);

        // Filter presets section
        const presetsSection = document.createElement("div");
        presetsSection.classList.add("presets-section");
        
        const presetsTitle = document.createElement("h4");
        presetsTitle.textContent = "Quick Filters";
        presetsSection.appendChild(presetsTitle);
        
        const presetsGrid = document.createElement("div");
        presetsGrid.classList.add("presets-grid");
        
        Object.entries(filterPresets).forEach(([key, preset]) => {
            const btn = document.createElement("button");
            btn.classList.add("preset-btn");
            btn.dataset.preset = key;
            btn.dataset.type = preset.type;
            if (activePresets.has(key)) btn.classList.add("active");
            btn.textContent = preset.name;
            btn.setAttribute("aria-pressed", activePresets.has(key));
            btn.onclick = (e) => {
                e.stopPropagation();
                toggleFilterPreset(key);
            };
            presetsGrid.appendChild(btn);
        });
        
        presetsSection.appendChild(presetsGrid);
        statsEl.appendChild(presetsSection);

        const sorted = Object.entries(categoryScores)
            .filter(([k, v]) => v && !hiddenCategories.has(k))
            .sort((a, b) => b[1] - a[1]);
        const top10 = sorted.slice(0, 10);
        const bottom10 = sorted.slice(Math.max(sorted.length - 10, 10));

        function createCatRow(cat, score) {
            const row = document.createElement("div");
            row.classList.add("cat-row");

            const nameSpan = document.createElement("span");
            nameSpan.classList.add("cat-name");
            nameSpan.title = convertCat(cat);
            nameSpan.textContent = convertCat(cat);

            const scoreSpan = document.createElement("span");
            scoreSpan.classList.add("cat-score");
            scoreSpan.textContent = score > 0 ? `+${score}` : String(score);

            const boostBtn = document.createElement("button");
            boostBtn.classList.add("cat-ctrl");
            boostBtn.textContent = "+";
            boostBtn.title = "Boost this category";
            boostBtn.setAttribute("aria-label", `Boost ${convertCat(cat)}`);
            boostBtn.onclick = (e) => {
                e.stopPropagation();
                categoryScores[cat] = (categoryScores[cat] || 0) + 200;
                scheduleEngagementUpdate();
            };

            const buryBtn = document.createElement("button");
            buryBtn.classList.add("cat-ctrl");
            buryBtn.textContent = "\u2212";
            buryBtn.title = "Bury this category";
            buryBtn.setAttribute("aria-label", `Bury ${convertCat(cat)}`);
            buryBtn.onclick = (e) => {
                e.stopPropagation();
                categoryScores[cat] = (categoryScores[cat] || 0) - 200;
                scheduleEngagementUpdate();
            };

            const hideBtn = document.createElement("button");
            hideBtn.classList.add("cat-ctrl");
            hideBtn.textContent = "\u00d7";
            hideBtn.title = "Hide this category";
            hideBtn.setAttribute("aria-label", `Hide ${convertCat(cat)}`);
            hideBtn.onclick = (e) => {
                e.stopPropagation();
                hiddenCategories.add(cat);
                scheduleEngagementUpdate();
            };

            row.appendChild(nameSpan);
            row.appendChild(scoreSpan);
            row.appendChild(boostBtn);
            row.appendChild(buryBtn);
            row.appendChild(hideBtn);
            return row;
        }

        // Top categories
        if (top10.length) {
            const topTitle = document.createElement("div");
            topTitle.classList.add("stats-section-title");
            topTitle.textContent = "Top Categories";
            statsEl.appendChild(topTitle);
            top10.forEach(([k, v]) => statsEl.appendChild(createCatRow(k, v)));
        }

        // Bottom categories
        if (bottom10.length) {
            const bottomTitle = document.createElement("div");
            bottomTitle.classList.add("stats-section-title");
            bottomTitle.textContent = "Bottom Categories";
            bottomTitle.style.marginTop = "12px";
            statsEl.appendChild(bottomTitle);
            bottom10.forEach(([k, v]) => statsEl.appendChild(createCatRow(k, v)));
        }

        // Hidden categories section
        if (hiddenCategories.size > 0) {
            const hiddenSection = document.createElement("div");
            hiddenSection.classList.add("hidden-section");

            const toggleBtn = document.createElement("button");
            toggleBtn.classList.add("hidden-toggle");
            toggleBtn.textContent = `Hidden (${hiddenCategories.size}) \u25B6`;
            toggleBtn.setAttribute("aria-expanded", "false");
            toggleBtn.setAttribute("aria-label", `Show ${hiddenCategories.size} hidden categories`);

            const hiddenList = document.createElement("div");
            hiddenList.classList.add("hidden-list");

            toggleBtn.onclick = (e) => {
                e.stopPropagation();
                const expanded = hiddenList.classList.toggle("expanded");
                toggleBtn.textContent = `Hidden (${hiddenCategories.size}) ${expanded ? "\u25BC" : "\u25B6"}`;
                toggleBtn.setAttribute("aria-expanded", String(expanded));
            };

            hiddenCategories.forEach(cat => {
                const row = document.createElement("div");
                row.classList.add("hidden-row");

                const nameSpan = document.createElement("span");
                nameSpan.classList.add("cat-name");
                nameSpan.textContent = convertCat(cat);

                const unhideBtn = document.createElement("button");
                unhideBtn.classList.add("unhide-btn");
                unhideBtn.textContent = "unhide";
                unhideBtn.setAttribute("aria-label", `Unhide ${convertCat(cat)}`);
                unhideBtn.onclick = (e) => {
                    e.stopPropagation();
                    hiddenCategories.delete(cat);
                    scheduleEngagementUpdate();
                };

                row.appendChild(nameSpan);
                row.appendChild(unhideBtn);
                hiddenList.appendChild(row);
            });

            hiddenSection.appendChild(toggleBtn);
            hiddenSection.appendChild(hiddenList);
            statsEl.appendChild(hiddenSection);
        }
    }

    // Apply engagement score to post categories
    // skipHidden: when true, categories in hiddenCategories are not scored
    function engagePost(post, amount, skipHidden = false) {
        post.allCategories.forEach(e => {
            if (skipHidden && hiddenCategories.has(e)) return;
            categoryScores[e] = (categoryScores[e] ?? 0) + amount;
            // Track explored categories for roulette feature
            // Track engagement time for decay feature
            if (amount > 0) {
                exploredCategories.add(e);
                categoryLastEngaged[e] = Date.now();
            }
        });
        savePreferences();
        return amount;
    }

    // Update session stats display
    function updateSessionStats() {
        document.getElementById('viewCount').textContent = articlesViewed;
        document.getElementById('likeCount').textContent = articlesLiked;
    }

    // Update history panel UI
    function updateHistoryUI() {
        const list = document.getElementById('historyList');
        if (!list) return;
        
        list.innerHTML = viewedHistory.map(item => `
            <div class="history-item" data-id="${item.id}" tabindex="0">
                ${item.thumb 
                    ? `<img src="${item.thumb}" alt="" loading="lazy">` 
                    : `<div class="no-thumb">üìÑ</div>`}
                <span class="history-item-title">${item.title}</span>
            </div>
        `).join('');
        
        // Add click handlers to scroll to article
        list.querySelectorAll('.history-item').forEach(el => {
            el.onclick = () => {
                const id = el.dataset.id;
                const post = document.querySelector(`.post[data-id="${id}"]`);
                if (post) {
                    post.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    post.focus();
                } else {
                    // Article not in DOM anymore, re-show it
                    const article = pagesArr.find(p => p.id == id);
                    if (article) {
                        createNextPost(article);
                        setTimeout(() => {
                            const newPost = document.querySelector(`.post[data-id="${id}"]`);
                            if (newPost) newPost.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100);
                    }
                }
                document.getElementById('historyPanel').style.display = 'none';
            };
        });
    }

    // Initialize history toggle
    function initHistoryToggle() {
        const toggle = document.getElementById('historyToggle');
        const panel = document.getElementById('historyPanel');
        const close = document.getElementById('historyClose');
        
        toggle.style.display = 'inline-block';
        
        toggle.onclick = () => {
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        };
        
        close.onclick = () => {
            panel.style.display = 'none';
        };
    }

    // Initialize keyboard shortcut hint for first-time users
    function initKeyboardHint() {
        const hint = document.getElementById('keyboardHint');
        const dismiss = document.getElementById('keyboardHintDismiss');
        const storageKey = 'xiki_keyboard_hint_seen';
        
        // Don't show if user has seen it before
        if (localStorage.getItem(storageKey)) return;
        
        // Show the hint
        hint.style.display = 'flex';
        
        // Mark as seen
        localStorage.setItem(storageKey, 'true');
        
        // Auto-dismiss after 8 seconds
        const autoDismiss = setTimeout(() => {
            hint.classList.add('fade-out');
            setTimeout(() => hint.style.display = 'none', 500);
        }, 8000);
        
        // Manual dismiss
        dismiss.onclick = () => {
            clearTimeout(autoDismiss);
            hint.classList.add('fade-out');
            setTimeout(() => hint.style.display = 'none', 500);
        };
        
        // Also dismiss if user presses ?
        document.addEventListener('keydown', function dismissOnQuestion(e) {
            if (e.key === '?') {
                clearTimeout(autoDismiss);
                hint.style.display = 'none';
                document.removeEventListener('keydown', dismissOnQuestion);
            }
        });
    }

    // Show double-tap heart animation
    function showDoubleTapHeart(postDiv) {
        const heart = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        heart.setAttribute("viewBox", "0 0 24 24");
        heart.classList.add("double-tap-heart");
        heart.innerHTML = '<path d="m12.06,21.01c3.94,0,13.77-11.36,8.56-16.37-4.59-4.41-8.61,1.58-8.61,1.58,0,0-4.02-5.99-8.61-1.58-5.22,5.01,4.61,16.37,8.56,16.37h.11Z" stroke-width="2" fill="red" stroke="red"/>';
        postDiv.appendChild(heart);
        heart.addEventListener("animationend", () => heart.remove());
    }

    // Show full-size image in popover
    function showPic(imgName) {
        const fullImg = document.createElement("img");
        fullImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${imgName.replace(/ /g, '_')}`;
        fullImg.popover = "auto";
        fullImg.classList.add("fullImg");
        document.body.appendChild(fullImg);
        fullImg.showPopover();
        fullImg.ontoggle = (e) => e.newState === "open" || fullImg.remove();
        fullImg.onclick = () => fullImg.hidePopover();
    }

    // Create and render a post element
    function createNextPost(specificPost = null) {
        const nextPost = specificPost || getNextPost();
        const postDiv = document.createElement("article");
        const postTitle = document.createElement("h1");
        const postP = document.createElement("p");
        const postYes = document.createElement("button");
        const shareBtn = document.createElement("button");
        const buttonRow = document.createElement("div");

        postDiv.classList.add("post");
        postDiv.dataset.testid = "post";
        postDiv.dataset.title = nextPost.title;
        postDiv.dataset.id = nextPost.id;
        postDiv.setAttribute("tabindex", "0");
        postDiv.setAttribute("aria-label", `Article: ${nextPost.title}. Press Enter to open on Wikipedia.`);

        const openWikipedia = () => {
            window.open(`https://en.wikipedia.org/wiki/${nextPost.title.replace(/ /g, '_')}`);
            if (!postDiv.dataset.engaged) {
                postDiv.dataset.engaged = engagePost(nextPost, 75);
            }
        };

        postDiv.onclick = (e) => {
            const now = Date.now();

            // Fix race condition: clear timer if tapping a different post
            if (singleTapTimer && lastTapTarget !== postDiv) {
                clearTimeout(singleTapTimer);
                singleTapTimer = null;
            }

            const isDoubleTap = (now - lastTapTime < 300) && (lastTapTarget === postDiv);

            if (isDoubleTap) {
                // Double-tap detected - trigger like
                clearTimeout(singleTapTimer);
                singleTapTimer = null;

                // Only animate and like if not already liked
                if (!postYes.dataset.liked) {
                    postYes.click();
                    showDoubleTapHeart(postDiv);
                }

                // Reset tap tracking
                lastTapTime = 0;
                lastTapTarget = null;
            } else {
                // First tap - wait to see if it's a double-tap
                lastTapTime = now;
                lastTapTarget = postDiv;

                // Delay single-tap action to check for second tap
                singleTapTimer = setTimeout(() => {
                    if (lastTapTarget === postDiv) {
                        openWikipedia();
                    }
                    lastTapTime = 0;
                    lastTapTarget = null;
                }, 300);
            }
        };

        postDiv.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openWikipedia();
            }
        };

        postTitle.innerText = nextPost.title;
        postP.innerText = nextPost.text;
        postYes.innerText = "Like";
        postYes.dataset.testid = "like-button";
        postYes.setAttribute("aria-label", `Like this article: ${nextPost.title}`);
        postYes.setAttribute("aria-pressed", "false");

        const handleLike = (e) => {
            postYes.dataset.liked = "true";
            postYes.setAttribute("aria-pressed", "true");
            if (!postYes.dataset.engaged) {
                // Reduced impact: 30 base + 2 per post (was 50 + 4)
                postYes.dataset.engaged = engagePost(nextPost, 30 + postsWithoutLike * 2);
                // Update session stats for likes
                articlesLiked++;
                currentStreak++;
                if (currentStreak > maxStreak) {
                    maxStreak = currentStreak;
                }
                updateSessionStats();
            }
            postsWithoutLike = 0;
            setTimeout(updateEngagement, 100);
            e.stopPropagation();
        };

        postYes.onclick = handleLike;

        shareBtn.innerText = "Share";
        shareBtn.classList.add("share-btn");
        shareBtn.dataset.testid = "share-button";
        shareBtn.setAttribute("aria-label", `Share this article: ${nextPost.title}`);

        shareBtn.onclick = (e) => {
            e.stopPropagation();
            const shareUrl = `${window.location.origin}${window.location.pathname}?article=${nextPost.id}`;
            navigator.clipboard.writeText(shareUrl)
                .then(() => {
                    shareBtn.classList.add("copied");
                    shareBtn.setAttribute("aria-label", "Link copied!");
                    setTimeout(() => {
                        shareBtn.classList.remove("copied");
                        shareBtn.setAttribute("aria-label", `Share this article: ${nextPost.title}`);
                    }, 2000);
                })
                .catch(() => {
                    // Fallback: show the URL in a prompt
                    prompt('Copy this link:', shareUrl);
                });
        };

        buttonRow.classList.add("button-row");

        postDiv.appendChild(postTitle);

        // "Why this?" button for algorithm transparency
        if (nextPost.recommendedBecause && nextPost.recommendedBecause.length > 0) {
            const whyBtn = document.createElement("button");
            whyBtn.classList.add("why-btn");
            whyBtn.innerText = "Why?";
            whyBtn.setAttribute("aria-label", "Why was this recommended?");
            whyBtn.setAttribute("aria-expanded", "false");
            
            const reasonDiv = document.createElement("div");
            reasonDiv.classList.add("recommendation-reason");
            reasonDiv.style.display = "none";
            
            // Create clickable category chips with dropdown menu
            nextPost.recommendedBecause.forEach((cat, idx) => {
                const wrapper = document.createElement("div");
                wrapper.classList.add("category-chip-wrapper");
                
                // Find the raw category name (before convertCat)
                const rawCat = [...nextPost.allCategories].find(c => convertCat(c) === cat) || cat;
                const currentStatus = getCategoryFilterStatus(rawCat);
                
                const chip = document.createElement("button");
                chip.classList.add("category-chip");
                if (currentStatus !== 'normal') chip.classList.add(currentStatus);
                
                const statusIcons = { blocked: 'üö´ ', reduced: '‚¨áÔ∏è ', boosted: '‚¨ÜÔ∏è ', normal: '' };
                chip.textContent = statusIcons[currentStatus] + cat;
                chip.setAttribute("aria-label", `Filter options for ${cat}`);
                chip.title = "Click for filter options";
                
                // Create dropdown menu
                const dropdown = document.createElement("div");
                dropdown.classList.add("category-dropdown");
                
                const actions = [
                    { action: 'boost', label: '‚¨ÜÔ∏è Boost', desc: 'Show more' },
                    { action: 'reduce', label: '‚¨áÔ∏è Reduce', desc: 'Show less' },
                    { action: 'block', label: 'üö´ Block', desc: 'Never show' },
                    { action: 'clear', label: '‚úì Clear', desc: 'Remove filter' }
                ];
                
                actions.forEach(({ action, label }) => {
                    const btn = document.createElement("button");
                    btn.textContent = label;
                    if (currentStatus === action || (currentStatus === 'normal' && action === 'clear')) {
                        btn.classList.add('active');
                    }
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        setCategoryFilter(rawCat, action);
                        
                        // Update chip appearance
                        const newStatus = getCategoryFilterStatus(rawCat);
                        chip.className = 'category-chip';
                        if (newStatus !== 'normal') chip.classList.add(newStatus);
                        chip.textContent = statusIcons[newStatus] + cat;
                        
                        // Update dropdown active states
                        dropdown.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                        if (newStatus === 'normal') {
                            dropdown.querySelector('button:last-child').classList.add('active');
                        } else {
                            btn.classList.add('active');
                        }
                    };
                    dropdown.appendChild(btn);
                });
                
                chip.onclick = (e) => {
                    e.stopPropagation();
                    // Toggle dropdown visibility on mobile (hover works on desktop)
                    const isVisible = dropdown.style.display === 'flex';
                    dropdown.style.display = isVisible ? 'none' : 'flex';
                };
                
                wrapper.appendChild(chip);
                wrapper.appendChild(dropdown);
                reasonDiv.appendChild(wrapper);
            });
            
            whyBtn.onclick = (e) => {
                e.stopPropagation();
                const isExpanded = reasonDiv.style.display !== "none";
                reasonDiv.style.display = isExpanded ? "none" : "flex";
                whyBtn.setAttribute("aria-expanded", !isExpanded);
                whyBtn.innerText = isExpanded ? "Why?" : "√ó";
            };
            
            postDiv.appendChild(whyBtn);
            postDiv.appendChild(reasonDiv);
        }

        postDiv.appendChild(postP);
        
        if (nextPost.thumb) {
            const postImg = document.createElement("img");
            postImg.src = `https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/${nextPost.thumb.replace(/ /g, '_')}&width=512`;
            postImg.classList.add("media");
            postImg.loading = "eager";
            postImg.onerror = () => postImg.remove();
            postImg.onclick = (e) => {
                showPic(nextPost.thumb);
                if (!postImg.dataset.engaged) {
                    postImg.dataset.engaged = engagePost(nextPost, 100);
                }
                e.stopPropagation();
            };
            postDiv.appendChild(postImg);
        }

        // More like this / Less like this feedback buttons
        const moreBtn = document.createElement("button");
        moreBtn.innerText = "More like this";
        moreBtn.classList.add("more-btn", "feedback-btn");
        moreBtn.setAttribute("aria-label", `More like this: ${nextPost.title}`);
        moreBtn.onclick = (e) => {
            e.stopPropagation();
            if (moreBtn.disabled) return;
            moreBtn.disabled = true;
            engagePost(nextPost, 150, true); // skipHidden=true for "More like this"
            updateEngagement();
            const gotIt = document.createElement("span");
            gotIt.classList.add("got-it");
            gotIt.textContent = "Got it";
            moreBtn.appendChild(gotIt);
            gotIt.addEventListener("animationend", () => gotIt.remove());
        };

        const lessBtn = document.createElement("button");
        lessBtn.innerText = "Less like this";
        lessBtn.classList.add("less-btn", "feedback-btn");
        lessBtn.setAttribute("aria-label", `Less like this: ${nextPost.title}`);
        lessBtn.onclick = (e) => {
            e.stopPropagation();
            if (lessBtn.disabled) return;
            lessBtn.disabled = true;
            engagePost(nextPost, -150);
            updateEngagement();
            const gotIt = document.createElement("span");
            gotIt.classList.add("got-it");
            gotIt.textContent = "Got it";
            lessBtn.appendChild(gotIt);
            gotIt.addEventListener("animationend", () => {
                gotIt.remove();
                // Slide the post away after "Got it" animation
                postDiv.classList.add("sliding-away");
                postDiv.addEventListener("animationend", () => {
                    postDiv.remove();
                }, { once: true });
            });
        };

        buttonRow.appendChild(moreBtn);
        buttonRow.appendChild(lessBtn);
        // Spacer pushes share/like to the right
        const spacer = document.createElement("div");
        spacer.classList.add("button-spacer");
        buttonRow.appendChild(spacer);
        buttonRow.appendChild(shareBtn);
        buttonRow.appendChild(postYes);
        postDiv.appendChild(buttonRow);
        engagePost(nextPost, -5);
        postsWithoutLike++;
        document.querySelector(".posts").appendChild(postDiv);

        // Update session stats
        articlesViewed++;
        viewedHistory.unshift({ title: nextPost.title, id: nextPost.id, thumb: nextPost.thumb });
        if (viewedHistory.length > 50) viewedHistory.pop(); // Keep last 50
        updateSessionStats();
        updateHistoryUI();
    }

    // Mark a post as seen (hard block + persist)
    function markPostSeen(post) {
        seenPostIds.add(post.id);
        post.seen = (post.seen ?? 0) + 1;
        saveSeenPosts();
    }

    // Get a purely random unseen post (helper) - with hard blocking
    function getRandomPost() {
        for (let i = 0; i < 1000; i++) {
            const randomPost = pagesArr[Math.floor(Math.random() * pagesArr.length)];
            if (!seenPostIds.has(randomPost.id)) {
                markPostSeen(randomPost);
                randomPost.recommendedBecause = ['üé≤ Serendipity'];
                return randomPost;
            }
        }
        // Fallback: if we've seen everything
        console.warn('Exhausted unique posts, allowing repeat');
        const randomPost = pagesArr[Math.floor(Math.random() * pagesArr.length)];
        markPostSeen(randomPost);
        randomPost.recommendedBecause = ['üé≤ Serendipity'];
        return randomPost;
    }

    // Get next post using the scoring algorithm
    function getNextPost() {
        // Explore mode OR aggressiveness 0: return purely random post
        if (exploreMode || algorithmAggressiveness === 0) {
            return getRandomPost();
        }

        // === SERENDIPITY INJECTION ===
        // Every 5-10 posts, inject a random one to break filter bubbles
        postsSinceRandom++;
        const serendipityThreshold = 5 + Math.floor(Math.random() * 6); // 5-10
        if (postsSinceRandom >= serendipityThreshold) {
            postsSinceRandom = 0;
            return getRandomPost();
        }

        // === VARIETY ENFORCEMENT ===
        // Penalize if we've had 4+ posts from the same dominant category
        let varietyPenaltyCategory = null;
        // Stricter variety: penalize after 2 consecutive posts (was 4)
        if (consecutiveSameCategory >= 2 && lastTopCategory) {
            varietyPenaltyCategory = lastTopCategory;
        }

        // === CATEGORY ROULETTE ===
        // 10% chance to boost a random unexplored category
        let rouletteBoostCategory = null;
        if (Math.random() < 0.1) {
            // Find categories we haven't engaged with yet
            const allCats = new Set();
            pagesArr.slice(0, 1000).forEach(p => p.allCategories?.forEach(c => allCats.add(c)));
            const unexplored = [...allCats].filter(c => 
                !exploredCategories.has(c) && 
                !hiddenCategories.has(c) &&
                c !== 'given names' && c !== 'surnames'
            );
            if (unexplored.length > 0) {
                rouletteBoostCategory = unexplored[Math.floor(Math.random() * unexplored.length)];
            }
        }

        // Scale category influence by aggressiveness (50 = normal, 100 = 2x, 25 = 0.5x)
        const aggFactor = algorithmAggressiveness / 50;

        const potentialPosts = [...Array(10000)]
            .map(() => pagesArr[Math.floor(Math.random() * pagesArr.length)])
            // Hard block: filter out already-seen posts
            .filter(post => !seenPostIds.has(post.id))
            .map(post => {
                // Stronger penalty (10x) as backup for any edge cases
                const initialScore = (post.thumb ? 5 : 0) + (3 ** (post.seen ?? 0) - 1) * -500000;
                let postScore = [...post.allCategories].reduce(
                    (sum, cat) => {
                        // Apply time-based decay to category score
                        const baseScore = (categoryScores[cat] ?? 0) * aggFactor;
                        let catScore = baseScore * getDecayFactor(cat);
                        
                        // === USER CATEGORY FILTERS ===
                        // Boosted categories get 3x score bonus
                        if (boostedCategories.has(cat)) {
                            catScore += 2000;
                        }
                        // Reduced categories get 75% penalty
                        if (reducedCategories.has(cat)) {
                            catScore -= 1500;
                        }
                        
                        // Variety: penalize overexposed category
                        if (cat === varietyPenaltyCategory) {
                            catScore -= 5000;
                        }
                        
                        // Roulette: boost unexplored category
                        if (cat === rouletteBoostCategory) {
                            catScore += 3000;
                        }
                        
                        return sum + catScore;
                    },
                    initialScore
                );
                post.score = postScore;
                return post;
            });

        // If all sampled posts were seen, sample more aggressively
        if (potentialPosts.length === 0) {
            console.warn('All sampled posts seen, trying harder...');
            for (let i = 0; i < 10000; i++) {
                const randomPost = pagesArr[Math.floor(Math.random() * pagesArr.length)];
                if (!seenPostIds.has(randomPost.id)) {
                    markPostSeen(randomPost);
                    return randomPost;
                }
            }
            // True fallback - everything seen
            const randomPost = pagesArr[Math.floor(Math.random() * pagesArr.length)];
            markPostSeen(randomPost);
            return randomPost;
        }

        let highestScore = -Infinity;
        let bestPost = potentialPosts[0];

        if (Math.random() < 0.4) {
            // Weighted random selection
            const minScore = Math.min(...potentialPosts.map(e => e.score));
            const maxScore = potentialPosts.reduce((sum, post) => sum + post.score - minScore, 0);
            const targetScore = Math.random() * maxScore;
            let scoreCount = 0;

            while (scoreCount < targetScore && potentialPosts.length) {
                const potentialPost = potentialPosts.pop();
                bestPost = potentialPost;
                scoreCount += potentialPost.score - minScore;
            }
        } else if (Math.random() > 0.3) {
            // Highest score selection
            potentialPosts.forEach(post => {
                if (post.score > highestScore) {
                    bestPost = post;
                    highestScore = post.score;
                }
            });
        }

        markPostSeen(bestPost);

        // Track top contributing categories for transparency
        const categoryContributions = [...bestPost.allCategories]
            .map(cat => ({ cat, score: categoryScores[cat] || 0 }))
            .filter(c => c.score > 0)
            .sort((a, b) => b.score - a.score)
            .slice(0, 3);

        if (categoryContributions.length > 0) {
            bestPost.recommendedBecause = categoryContributions.map(c => convertCat(c.cat));
            
            // Track for variety enforcement
            const topCat = categoryContributions[0].cat;
            if (topCat === lastTopCategory) {
                consecutiveSameCategory++;
            } else {
                lastTopCategory = topCat;
                consecutiveSameCategory = 1;
            }
        } else {
            bestPost.recommendedBecause = null;
            lastTopCategory = null;
            consecutiveSameCategory = 0;
        }

        // Roulette feedback
        if (rouletteBoostCategory && bestPost.allCategories.has(rouletteBoostCategory)) {
            bestPost.recommendedBecause = ['üé∞ ' + convertCat(rouletteBoostCategory)];
        }

        return bestPost;
    }

    // Render loop - creates posts as user scrolls
    function render() {
        if (document.documentElement.scrollHeight < scrollY + innerHeight + 1500) {
            createNextPost();
        }
        requestAnimationFrame(render);
    }

    // Add a category picker button
    function addPickableCategory(cat, checked) {
        const escapedCat = cat.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        if (document.querySelector(`.categoryPicker input[data-category="${escapedCat}"]`)) {
            return;
        }
        const picker = document.createElement("label");
        const check = document.createElement("input");
        const labelText = `${cat.slice(0, 1).toUpperCase()}${cat.slice(1).toLowerCase()}`;
        check.type = "checkbox";
        picker.innerText = labelText;
        picker.appendChild(check);
        picker.classList.add("categoryPicker");
        check.dataset.category = cat;
        if (checked) check.checked = true;
        categoryPickList.appendChild(picker);
    }

    // Stream reader helper
    async function* streamToAsyncIterable(stream) {
        const reader = stream.getReader();
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) return;
                yield value;
            }
        } finally {
            reader.releaseLock();
        }
    }

    // Format bytes to human readable
    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Format seconds to human readable time
    function formatTime(seconds) {
        if (seconds < 60) return Math.ceil(seconds) + 's';
        const mins = Math.floor(seconds / 60);
        const secs = Math.ceil(seconds % 60);
        return `${mins}m ${secs}s`;
    }

    // Fetch file with progress tracking and retry logic
    async function getFileWithProgress(url, retryCount = 0) {
        const MAX_RETRIES = 3;
        const loadingProgress = document.getElementById('loadingProgress');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const loadingDetails = document.getElementById('loadingDetails');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const retryBtn = document.getElementById('retryBtn');

        loadingProgress.style.display = 'block';
        errorMessage.classList.remove('visible');

        try {
            const resp = await fetch(url, { cache: "force-cache" });

            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            }

            let responseSize = 0;
            const bytes = new Uint8Array(DATA_SIZE);
            const startTime = Date.now();
            let speedSamples = [];
            let lastSampleTime = startTime;
            let lastSampleSize = 0;

            for await (const chunk of streamToAsyncIterable(resp.body)) {
                bytes.set(chunk, responseSize);
                responseSize += chunk.length;

                const now = Date.now();
                const percent = Math.floor(responseSize / DATA_SIZE * 100);

                // Calculate speed every 500ms
                if (now - lastSampleTime >= 500) {
                    const bytesInInterval = responseSize - lastSampleSize;
                    const secondsInInterval = (now - lastSampleTime) / 1000;
                    const currentSpeed = bytesInInterval / secondsInInterval;

                    speedSamples.push(currentSpeed);
                    if (speedSamples.length > 5) speedSamples.shift();

                    lastSampleTime = now;
                    lastSampleSize = responseSize;
                }

                // Update UI
                loadingProgressBar.style.width = percent + '%';
                startBtn.innerText = `Downloading... ${percent}%`;

                if (speedSamples.length > 0) {
                    const avgSpeed = speedSamples.reduce((a, b) => a + b, 0) / speedSamples.length;
                    const remaining = DATA_SIZE - responseSize;
                    const eta = remaining / avgSpeed;
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)} ¬∑ ${formatBytes(avgSpeed)}/s ¬∑ ~${formatTime(eta)} remaining`;
                } else {
                    loadingDetails.innerText = `${formatBytes(responseSize)} of ${formatBytes(DATA_SIZE)}`;
                }
            }

            loadingProgressBar.style.width = '100%';
            startBtn.innerText = `Download complete, processing...`;
            loadingDetails.innerText = '';
            await new Promise(requestAnimationFrame);
            await new Promise(requestAnimationFrame);
            return JSON.parse(new TextDecoder().decode(bytes.subarray(0, responseSize)));

        } catch (error) {
            console.error('Download failed:', error);

            if (retryCount < MAX_RETRIES) {
                const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                startBtn.innerText = `Connection lost, retrying in ${delay/1000}s...`;
                loadingDetails.innerText = `Attempt ${retryCount + 2} of ${MAX_RETRIES + 1}`;
                await new Promise(r => setTimeout(r, delay));
                return getFileWithProgress(url, retryCount + 1);
            }

            // All retries failed
            loadingProgress.style.display = 'none';
            loadingDetails.innerText = '';
            errorMessage.classList.add('visible');
            errorText.innerText = error.message || 'Network error. Please check your connection.';
            startBtn.innerText = 'Loading failed';

            // Return a promise that resolves when user clicks retry
            return new Promise((resolve) => {
                retryBtn.onclick = () => {
                    resolve(getFileWithProgress(url, 0));
                };
            });
        }
    }

    // ============================================
    // Feature 2: Feed Refresh
    // ============================================

    function refreshFeed() {
        // Clear all posts from DOM
        const postsContainer = document.querySelector(".posts");
        postsContainer.innerHTML = "";
        // Reset seen counters and stale recommendation reasons
        pagesArr.forEach(p => { delete p.seen; delete p.recommendedBecause; });
        // Reset like streak counter
        postsWithoutLike = 0;
        // Reset randomness counters
        postsSinceRandom = 0;
        lastTopCategory = null;
        consecutiveSameCategory = 0;
        // Note: exploredCategories persists across refresh (intentional)
        // Scroll to top
        window.scrollTo(0, 0);
        // The render loop is already running via rAF, new posts auto-generate
    }

    // Pull-to-refresh state
    let pullStartY = 0;
    let pullDist = 0;
    let isPulling = false;
    const PULL_THRESHOLD = 80;

    function initPullToRefresh() {
        const postsContainer = document.querySelector(".posts");

        // Create pull indicator element
        const indicator = document.createElement("div");
        indicator.classList.add("pull-to-refresh-indicator");
        indicator.id = "pullIndicator";
        indicator.innerHTML = '<span>‚Üì</span> Pull to refresh';
        postsContainer.parentNode.insertBefore(indicator, postsContainer);

        // Common handlers for both touch and pointer events
        function handlePullStart(clientY) {
            if (window.scrollY <= 0) {
                pullStartY = clientY;
                isPulling = true;
            }
        }

        function handlePullMove(clientY, preventDefault) {
            if (!isPulling) return;
            pullDist = clientY - pullStartY;
            if (pullDist < 0) pullDist = 0;
            if (pullDist > 0 && window.scrollY <= 0) {
                if (preventDefault) preventDefault();
                indicator.classList.add("active");
                const progress = Math.min(pullDist / PULL_THRESHOLD, 1);
                indicator.style.height = (progress * 48) + "px";
                indicator.style.opacity = progress;
                if (pullDist >= PULL_THRESHOLD) {
                    indicator.innerHTML = '<span style="color: #22c55e">‚úì</span> Release to refresh!';
                } else {
                    indicator.innerHTML = '<span>‚Üì</span> Pull to refresh';
                }
            }
        }

        function handlePullEnd() {
            if (isPulling && pullDist >= PULL_THRESHOLD) {
                indicator.innerHTML = '<span class="spinner">‚Üª</span> Refreshing...';
                // Refresh immediately, then hide indicator
                refreshFeed();
                showToast("üîÑ Feed refreshed!");
                setTimeout(() => {
                    indicator.classList.remove("active");
                    indicator.style.height = "0";
                    indicator.style.opacity = "0";
                    indicator.innerHTML = '<span>‚Üì</span> Pull to refresh';
                }, 300);
            } else {
                indicator.classList.remove("active");
                indicator.style.height = "0";
                indicator.style.opacity = "0";
            }
            isPulling = false;
            pullDist = 0;
        }

        // Touch events (mobile)
        postsContainer.addEventListener("touchstart", (e) => {
            handlePullStart(e.touches[0].clientY);
        }, { passive: true });

        postsContainer.addEventListener("touchmove", (e) => {
            handlePullMove(e.touches[0].clientY, () => e.preventDefault());
        }, { passive: false });

        postsContainer.addEventListener("touchend", handlePullEnd, { passive: true });

        // Pointer events (desktop mouse + touch)
        let isPointerPulling = false;
        let capturedPointerId = null;
        
        postsContainer.addEventListener("pointerdown", (e) => {
            if (e.pointerType === 'touch') return; // Handled by touch events
            // Don't start pull if clicking on interactive elements
            const target = e.target;
            if (target.closest('button, a, input, [role="button"]')) return;
            if (window.scrollY > 0) return; // Only at top of page
            isPointerPulling = true;
            capturedPointerId = e.pointerId;
            handlePullStart(e.clientY);
            postsContainer.setPointerCapture(e.pointerId);
        });

        postsContainer.addEventListener("pointermove", (e) => {
            if (e.pointerType === 'touch' || !isPointerPulling) return;
            handlePullMove(e.clientY, () => e.preventDefault());
        });

        postsContainer.addEventListener("pointerup", (e) => {
            if (e.pointerType === 'touch') return;
            if (isPointerPulling) {
                handlePullEnd();
                isPointerPulling = false;
                if (capturedPointerId !== null) {
                    try { postsContainer.releasePointerCapture(capturedPointerId); } catch(err) {}
                    capturedPointerId = null;
                }
            }
        });

        postsContainer.addEventListener("pointercancel", (e) => {
            if (isPointerPulling) {
                indicator.classList.remove("active");
                indicator.style.height = "0";
                indicator.style.opacity = "0";
                indicator.innerHTML = '<span>‚Üì</span> Pull to refresh';
                isPulling = false;
                pullDist = 0;
                isPointerPulling = false;
                capturedPointerId = null;
            }
        });
        
        // Also handle lostpointercapture for robustness
        postsContainer.addEventListener("lostpointercapture", (e) => {
            if (isPointerPulling) {
                handlePullEnd();
                isPointerPulling = false;
                capturedPointerId = null;
            }
        });
    }

    // ============================================
    // Feature 4: Mobile Sidebar Drawer
    // ============================================
    function initMobileDrawer() {
        const statsEl = document.querySelector(".stats");
        const backdrop = document.getElementById("statsBackdrop");
        const toggleBtn = document.getElementById("statsToggleBtn");
        const closeBtn = statsEl.querySelector(".stats-close");

        function openDrawer() {
            statsEl.classList.add("open");
            backdrop.classList.add("visible");
        }

        function closeDrawer() {
            statsEl.classList.remove("open");
            backdrop.classList.remove("visible");
        }

        toggleBtn.onclick = (e) => {
            e.stopPropagation();
            openDrawer();
        };

        backdrop.onclick = () => closeDrawer();

        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && statsEl.classList.contains("open")) {
                closeDrawer();
            }
        });

        if (closeBtn) {
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeDrawer();
            };
        }

        // Swipe-to-dismiss on the drawer
        let drawerTouchStartX = 0;
        let drawerTouchCurrentX = 0;
        let isDragging = false;

        statsEl.addEventListener("touchstart", (e) => {
            drawerTouchStartX = e.touches[0].clientX;
            drawerTouchCurrentX = e.touches[0].clientX;
            isDragging = true;
        }, { passive: true });

        statsEl.addEventListener("touchmove", (e) => {
            if (!isDragging) return;
            drawerTouchCurrentX = e.touches[0].clientX;
            const dx = drawerTouchCurrentX - drawerTouchStartX;
            if (dx > 20) {
                statsEl.style.transform = `translateX(${dx}px)`;
            }
        }, { passive: true });

        statsEl.addEventListener("touchend", () => {
            if (!isDragging) return;
            const dx = drawerTouchCurrentX - drawerTouchStartX;
            statsEl.style.transform = "";
            if (dx > 80) {
                closeDrawer();
            }
            isDragging = false;
            drawerTouchCurrentX = 0;
        }, { passive: true });
    }

    // Keyboard shortcuts for power users
    function initKeyboardShortcuts() {
        // Get the post currently most visible in viewport
        function getCurrentPost() {
            const posts = document.querySelectorAll('.post');
            const viewportCenter = window.innerHeight / 2;
            let closest = null;
            let closestDist = Infinity;

            for (const post of posts) {
                const rect = post.getBoundingClientRect();
                const postCenter = rect.top + rect.height / 2;
                const dist = Math.abs(postCenter - viewportCenter);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = post;
                }
            }
            return closest;
        }

        // Scroll to a specific post index
        function scrollToPost(post) {
            if (!post) return;
            post.scrollIntoView({ behavior: 'smooth', block: 'center' });
            post.focus();
        }

        // Get next/previous post relative to current
        function getAdjacentPost(direction) {
            const posts = Array.from(document.querySelectorAll('.post'));
            const current = getCurrentPost();
            if (!current) return posts[0] || null;
            
            const idx = posts.indexOf(current);
            if (direction === 'next') {
                return posts[idx + 1] || current;
            } else {
                return posts[idx - 1] || current;
            }
        }

        // Show help modal
        let helpVisible = false;
        function toggleHelp() {
            let helpEl = document.getElementById('keyboardHelp');
            if (!helpEl) {
                helpEl = document.createElement('div');
                helpEl.id = 'keyboardHelp';
                helpEl.innerHTML = `
                    <div class="keyboard-help-content">
                        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                        <table>
                            <tr><td><kbd>J</kbd></td><td>Next post</td></tr>
                            <tr><td><kbd>K</kbd></td><td>Previous post</td></tr>
                            <tr><td><kbd>L</kbd></td><td>Like post</td></tr>
                            <tr><td><kbd>M</kbd></td><td>More like this</td></tr>
                            <tr><td><kbd>N</kbd></td><td>Less like this</td></tr>
                            <tr><td><kbd>O</kbd> / <kbd>Enter</kbd></td><td>Open on Wikipedia</td></tr>
                            <tr><td><kbd>R</kbd></td><td>Refresh feed</td></tr>
                            <tr><td><kbd>E</kbd></td><td>Toggle explore mode</td></tr>
                            <tr><td><kbd>A</kbd></td><td>Cycle algorithm strength</td></tr>
                            <tr><td><kbd>H</kbd></td><td>Toggle history</td></tr>
                            <tr><td><kbd>S</kbd></td><td>Toggle sidebar</td></tr>
                            <tr><td><kbd>?</kbd></td><td>Show/hide this help</td></tr>
                            <tr><td><kbd>Esc</kbd></td><td>Close sidebar/help</td></tr>
                        </table>
                        <p class="help-dismiss">Press <kbd>?</kbd> or <kbd>Esc</kbd> to close</p>
                    </div>
                `;
                helpEl.style.cssText = `
                    position: fixed; inset: 0; z-index: 10000;
                    background: rgba(0,0,0,0.8); display: flex;
                    align-items: center; justify-content: center;
                `;
                helpEl.querySelector('.keyboard-help-content').style.cssText = `
                    background: var(--bg-secondary); color: var(--text-primary);
                    padding: 24px 32px; border-radius: 12px; max-width: 320px;
                `;
                helpEl.querySelectorAll('kbd').forEach(k => {
                    k.style.cssText = `
                        background: var(--bg-tertiary); padding: 2px 8px;
                        border-radius: 4px; font-family: monospace;
                        border: 1px solid var(--border-color);
                    `;
                });
                helpEl.querySelectorAll('td').forEach((td, i) => {
                    td.style.padding = '4px 12px';
                    if (i % 2 === 0) td.style.textAlign = 'right';
                });
                helpEl.querySelector('h3').style.marginTop = '0';
                helpEl.querySelector('.help-dismiss').style.cssText = `
                    text-align: center; opacity: 0.7; font-size: 0.9em; margin-bottom: 0;
                `;
                helpEl.onclick = () => toggleHelp();
                document.body.appendChild(helpEl);
                helpVisible = true;
            } else {
                helpEl.remove();
                helpVisible = false;
            }
        }

        document.addEventListener('keydown', (e) => {
            // Don't fire shortcuts when typing in inputs
            if (e.target.matches('input, textarea, select')) return;
            // Don't fire if modifier keys are held (allow browser shortcuts)
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            const key = e.key.toLowerCase();
            const current = getCurrentPost();

            switch (key) {
                case 'j': // Next post
                    e.preventDefault();
                    scrollToPost(getAdjacentPost('next'));
                    break;

                case 'k': // Previous post
                    e.preventDefault();
                    scrollToPost(getAdjacentPost('prev'));
                    break;

                case 'l': // Like
                    if (current) {
                        e.preventDefault();
                        const likeBtn = current.querySelector('[data-testid="like-button"]');
                        if (likeBtn && !likeBtn.dataset.liked) likeBtn.click();
                    }
                    break;

                case 'm': // More like this
                    if (current) {
                        e.preventDefault();
                        const moreBtn = current.querySelector('.more-btn');
                        if (moreBtn && !moreBtn.disabled) moreBtn.click();
                    }
                    break;

                case 'n': // Less like this  
                    if (current) {
                        e.preventDefault();
                        const lessBtn = current.querySelector('.less-btn');
                        if (lessBtn && !lessBtn.disabled) lessBtn.click();
                    }
                    break;

                case 'o': // Open on Wikipedia
                case 'enter':
                    if (current && e.key === 'o') { // Only 'o', Enter handled by post's own handler
                        e.preventDefault();
                        current.click();
                    }
                    break;

                case 'r': // Refresh
                    e.preventDefault();
                    refreshFeed();
                    break;

                case 'e': // Toggle explore mode
                    e.preventDefault();
                    document.getElementById('exploreBtn').click();
                    break;

                case 'a': // Cycle algorithm aggressiveness
                    e.preventDefault();
                    const presets = [0, 25, 50, 75, 100];
                    const currentIdx = presets.indexOf(algorithmAggressiveness);
                    algorithmAggressiveness = presets[(currentIdx + 1) % presets.length];
                    scheduleEngagementUpdate();
                    savePreferences();
                    break;

                case 'h': // Toggle history
                    e.preventDefault();
                    document.getElementById('historyToggle').click();
                    break;

                case 's': // Toggle sidebar
                    e.preventDefault();
                    document.getElementById('statsToggleBtn').click();
                    break;

                case '?': // Help
                    e.preventDefault();
                    toggleHelp();
                    break;

                case 'escape':
                    if (helpVisible) {
                        e.preventDefault();
                        toggleHelp();
                    }
                    // Sidebar close is handled elsewhere
                    break;
            }
        });
    }

    // Start the feed (extracted so both auth and guest paths can use it)
    function startFeed(sharedArticle) {
        startScreen.hidePopover();
        startScreen.remove();

        // Initialize mobile sidebar drawer
        initMobileDrawer();

        // Show floating refresh button and init pull-to-refresh
        document.getElementById("refreshBtn").style.display = "flex";
        document.getElementById("refreshBtn").onclick = (e) => {
            e.stopPropagation();
            refreshFeed();
        };
        initPullToRefresh();

        // Show explore mode toggle button
        const exploreBtn = document.getElementById("exploreBtn");
        exploreBtn.style.display = "flex";
        exploreBtn.onclick = (e) => {
            e.stopPropagation();
            exploreMode = !exploreMode;
            exploreBtn.classList.toggle("active", exploreMode);
            exploreBtn.setAttribute("aria-pressed", exploreMode);
            exploreBtn.setAttribute("aria-label", exploreMode ? "Exit explore mode" : "Enter explore mode");
            // Show toast feedback
            showToast(exploreMode ? "üé≤ Explore mode ON - random articles!" : "üéØ Explore mode OFF - back to personalized");
        };
        initKeyboardShortcuts();
        initHistoryToggle();
        initKeyboardHint();

        // Show logout/delete buttons if logged in
        if (isLoggedIn()) {
            document.getElementById('logoutBtn').style.display = 'block';
            document.getElementById('deleteAccountBtn').style.display = 'block';
        }
        // If there's a shared article, show it first
        if (sharedArticle) {
            sharedArticle.seen = (sharedArticle.seen ?? 0) + 1;
            createNextPost(sharedArticle);
        }
        requestAnimationFrame(render);
    }

    // Main initialization
    async function main() {
        // Load persisted seen posts before anything else
        loadSeenPosts();
        loadBlockedCategories();

        startScreen.showPopover();

        // Configure auth section based on login state
        const authSection = document.getElementById('authSection');
        const categoryPickerSection = document.getElementById('categoryPickerSection');

        if (isLoggedIn()) {
            // Show welcome message instead of auth form
            const welcomeDiv = document.createElement('div');
            welcomeDiv.className = 'auth-welcome';
            welcomeDiv.appendChild(document.createTextNode('Welcome back, '));
            const strong = document.createElement('strong');
            strong.style.margin = '0 4px';
            strong.textContent = currentUser();
            welcomeDiv.appendChild(strong);
            welcomeDiv.appendChild(document.createTextNode('! '));
            const logoutLink = document.createElement('a');
            logoutLink.textContent = 'Log out';
            logoutLink.onclick = logout;
            logoutLink.style.cursor = 'pointer';
            welcomeDiv.appendChild(logoutLink);
            authSection.innerHTML = '';
            authSection.appendChild(welcomeDiv);
            // Hide category picker for logged-in users
            categoryPickerSection.style.display = 'none';
        }

        defaultCategories.forEach(e => addPickableCategory(e));
        startBtn.innerText = "Xikipedia is loading... (downloading ~40MB of data)";

        const smoldata = await getFileWithProgress("smoldata.json");

        const subCategories = smoldata.subCategories;
        noPageMaps = smoldata.noPageMaps;
        delete smoldata.subCategories;
        delete smoldata.noPageMaps;

        let i = 0;
        const wikiLen = smoldata.pages.length;
        const loading = document.querySelector("#loading");
        let lastFrame = Date.now();

        const loadingDetails = document.getElementById('loadingDetails');
        const loadingProgressBar = document.getElementById('loadingProgressBar');

        let filteredCount = 0;

        while (smoldata.pages.length) {
            const e = smoldata.pages.pop();

            // Skip articles with very short text (less than 100 chars)
            if (e[2] && e[2].length < 100) {
                filteredCount++;
                i++;
                continue;
            }

            const tempPage = {
                title: e[0],
                id: e[1],
                text: e[2],
                thumb: e[3],
                categories: e[4],
                links: e[5]
            };

            if (i % 1000 === 0 && Date.now() - lastFrame > 20) {
                const percent = (i / wikiLen * 100).toFixed(0);
                startBtn.innerText = `Processing articles... ${percent}%`;
                loadingProgressBar.style.width = percent + '%';
                loadingDetails.innerText = `${i.toLocaleString()} of ${wikiLen.toLocaleString()} articles`;
                await new Promise(r => requestAnimationFrame(r));
                lastFrame = Date.now();
            }
            i++;

            tempPage.allCategories = new Set(recursiveCategories(subCategories, [...tempPage.categories], 0));
            tempPage.allCategories.add(`p:${tempPage.id}`);
            tempPage.allCategories.add(...tempPage.links.map(e => `p:${e}`));
            pagesArr.push(tempPage);
        }

        loading.remove();
        document.getElementById('loadingProgress').style.display = 'none';
        document.getElementById('loadingDetails').innerText = `${wikiLen.toLocaleString()} articles ready`;
        startBtn.removeAttribute("disabled");
        categorySearchInput.removeAttribute("disabled");
        startBtn.innerText = "I'm an adult, continue";

        // Check for shared article URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const sharedArticleId = urlParams.get('article');
        let sharedArticle = null;
        if (sharedArticleId) {
            sharedArticle = pagesArr.find(p => p.id == sharedArticleId);
            if (!sharedArticle) {
                // Article not found - log warning
                console.warn('Shared article not found:', sharedArticleId);
            }
            // Clear the URL parameter
            window.history.replaceState({}, '', window.location.pathname);
        }

        // If logged in, load saved preferences and auto-start
        if (isLoggedIn()) {
            try {
                const prefsResp = await fetch('/api/preferences', {
                    headers: getAuthHeaders()
                });
                if (!prefsResp.ok) throw new Error('Failed to load preferences');
                const prefs = await prefsResp.json();

                // Apply saved categoryScores (merge, preserving defaults like given names: -1000)
                if (prefs.categoryScores) {
                    Object.entries(prefs.categoryScores).forEach(([k, v]) => {
                        categoryScores[k] = v;
                    });
                }

                // Apply saved hiddenCategories if present
                if (prefs.hiddenCategories && Array.isArray(prefs.hiddenCategories)) {
                    prefs.hiddenCategories.forEach(cat => hiddenCategories.add(cat));
                }

                // Apply saved algorithmAggressiveness if present
                if (typeof prefs.algorithmAggressiveness === 'number') {
                    algorithmAggressiveness = Math.max(0, Math.min(100, prefs.algorithmAggressiveness));
                }

                // Auto-start the feed
                startFeed(sharedArticle);
                return;
            } catch (e) {
                console.warn('Failed to load preferences, clearing auth:', e);
                localStorage.removeItem('xiki_token');
                localStorage.removeItem('xiki_username');
                // Fall through to normal start screen - reload to show guest UI
                window.location.reload();
                return;
            }
        }

        startBtn.onclick = () => {
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                categoryScores[e.dataset.category] = defaultCategories.includes(e.dataset.category) ? 1000 : 5000;
            });
            document.querySelectorAll(".categoryPicker>input:checked").forEach(e => {
                if (defaultCategories.includes(e.dataset.category)) return;
                const page = pagesArr.find(x => x.title.toLowerCase() === e.dataset.category);
                if (page) engagePost(page, 100);
            });
            startFeed(sharedArticle);
        };
    }

    // Expose state for testing
    window.categoryScores = categoryScores;
    window.hiddenCategories = hiddenCategories;
    window.pagesArr = pagesArr;
    window.seenPostIds = seenPostIds;
    // Expose algorithmAggressiveness as getter/setter for testing
    Object.defineProperty(window, 'algorithmAggressiveness', {
        get: () => algorithmAggressiveness,
        set: (v) => { algorithmAggressiveness = v; }
    });
    // Clear seen posts (for testing or fresh start)
    window.clearSeenPosts = () => {
        seenPostIds.clear();
        localStorage.removeItem('xiki_seen_posts');
        pagesArr.forEach(p => p.seen = 0);
    };
    // Expose postsWithoutLike as a getter for testing
    Object.defineProperty(window, 'postsWithoutLike', { get: () => postsWithoutLike });
    // Expose refreshFeed for testing
    window.refreshFeed = refreshFeed;
    window.viewedHistory = viewedHistory;
    // Expose exploreMode for testing
    Object.defineProperty(window, 'exploreMode', {
        get: () => exploreMode,
        set: (v) => { exploreMode = v; }
    });

    window.onload = main;

    // ============================================
    // Service Worker Registration & Handlers
    // ============================================

    // Service Worker registration (can run immediately, no DOM needed)
    let swRegistration = null;
    let updateAvailable = false;

    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
            .then(registration => {
                swRegistration = registration;
                console.log('SW registered:', registration.scope);
                
                // Check for updates
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && 
                            navigator.serviceWorker.controller) {
                            // New version available
                            showUpdateToast();
                        }
                    });
                });
            })
            .catch(err => console.error('SW registration failed:', err));
        
        // Listen for messages from SW
        navigator.serviceWorker.addEventListener('message', event => {
            if (event.data?.type === 'CONTENT_UPDATED') {
                // index.html was updated in background
                if (!updateAvailable) {
                    showUpdateToast();
                }
            }
            if (event.data?.type === 'SW_ACTIVATED') {
                console.log('SW activated, version:', event.data.version);
            }
        });
    }

    function showUpdateToast() {
        updateAvailable = true;
        const toast = document.getElementById('updateToast');
        if (toast) {
            toast.classList.add('visible');
        }
    }

    function hideUpdateToast() {
        const toast = document.getElementById('updateToast');
        if (toast) {
            toast.classList.remove('visible');
        }
    }

    // Online/offline status tracking and UI setup (needs DOM)
    document.addEventListener('DOMContentLoaded', () => {
        const offlineIndicator = document.getElementById('offlineIndicator');
        const updateBtn = document.getElementById('updateBtn');
        const updateDismiss = document.getElementById('updateDismiss');

        function updateOnlineStatus() {
            if (offlineIndicator) {
                offlineIndicator.classList.toggle('visible', !navigator.onLine);
            }
        }

        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        updateOnlineStatus(); // Initial check

        // Update button handler
        if (updateBtn) {
            updateBtn.addEventListener('click', () => {
                if (swRegistration?.waiting) {
                    // Tell waiting SW to take over
                    swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });
                }
                // Reload to get new version
                window.location.reload();
            });
        }

        // Dismiss button handler
        if (updateDismiss) {
            updateDismiss.addEventListener('click', hideUpdateToast);
        }
    });

    // Keyboard shortcut: Ctrl+Shift+U to check for updates (dev convenience)
    document.addEventListener('keydown', e => {
        if (e.key === 'u' && e.ctrlKey && e.shiftKey) {
            if (swRegistration) {
                swRegistration.update().then(() => {
                    console.log('Checked for SW updates');
                });
            }
        }
    });
</script>
    <!-- Offline indicator -->
    <div id="offlineIndicator" role="status" aria-live="polite">
        You're offline
    </div>

    <!-- Update toast -->
    <div id="updateToast" role="alert" aria-live="assertive">
        <span>A new version is available!</span>
        <button id="updateBtn">Refresh to update</button>
        <button class="dismiss" id="updateDismiss">Not now</button>
    </div>
</body>
</html>
